
/*
0. 表达式和语句
    a. 声明语句
        声明语言一些基本要素，如定义结构体、函数，引入模块、赋值等
    b. 流程控制语句
        如条件分支、循环语句等
    c. 表达式语句
        返回相应值
    d. 宏语句
        用于文本替换或者生成指定代码

1. Rust 语法骨架
    a. 语法骨架(源代码)
        #![allow(unused)]
        use std::collections::HashMap;

        fn add_one(i: &mut u32) {
            *i += 1;
        }

        fn plus_one(i: &u32) -> u32 {
            let i = i + 1;
            i
        }

        fn main() {
            let mut a = 41;
            add_one(&mut a);
            println!("{:?}",a);

            let a = 41;
            let b = plus_one(&a);
            println!("{:?}",b);

            let mut h = HashMap::new();
            h.insert("answer",42);
            println!("answer is {:?}",h["answer"]);
        }

    b. (语法骨架)优化后为一行
        #![allow(unused)]use std::collections::HashMap;fn add_one(i:&mut u32){*i+=1;}fn plus_one
        (i:&u32)->u32{let i=i+1;i}fn main(){let mut a=41;add_one(&mut a);println!("{:?}",a);
        let a=41;let b=plus_one(&a);println!("{:?}",b); let mut h=HashMap::new();h.insert
        ("answer",42);println!("answer is {:?}",h["answer"]);}
        // 分析发现：Rust 之所以能正常识别，是因其有非常规律的分割单位
           首先以" #![allow[unused)] "属性：其作用是保留未被使用的函数或变量；
           接着是 use 语句：其作用是从标准库 collections 模块导入 HashMap;(后以分号结尾[声明语句])；
           再后是 fn 关键字声明的函数(包括参数[圆括号]及函数体[花括号])

    c. Rust 语法" 骨架 "简化
       #![...]use xx;fn xx(...){...)fn xx(...){...}fn main(){...}

    d. 继续简化(即去除关键字后)后结构
       #![...];{ ; };{};{;;}
       即简化为 Rust 语法" 骨架 "的三个元素：
           属性 : 类似于 #![ ... ]
           分号 ：行分隔符
           花括号 : 块分隔符

2. Rust 面向表达式的语言： Rust 是由"属性、分号及块"构成
    a. 分号表达式 : 单元类型(unit type)
        ; -> ()
        // (分号表达式并不是在任何时候都会求值)分号表达式仅处在块中最后一个表达式时才会求值
    b. 块表达式 ：
        块表达式的值即是块末行表达式的返回值
    c. 综述三条规则：
         (0). 分号表达式返回值永远为自身的单元( Unit 类型) ： ()
         (1). 分号表达式只有在块表达式最后一行才会进行求值，其它时候仅作为"连接符"存在
         (2). 块表达式只对最后一行表达式进行求值

3. 根据表达式三条规则：以下 main 函数能正常编译
    a. 首先 main 函数就是一个大的块表达式，因其签名并未标出返回值故其返回默认的单元 () 类型
    b. main 函数体内最后一个分号会返回一个单元 () 类型
    c. main 函数体内非末行分号不会求值，仅作为连接符的存在(函数体内行分隔符使用分号来分隔)
    // Rust 将语法分为基本的语句和表达式，如此可将带分号的行代码都以看作是返回单元类型的值，这样的代码即是
       语句(因为单元值本身并没有什么意义)；语句又分为声明语句和表达式语句
    // Rust 中除声明语句外，一切皆为表达式(包括流程控制、函数调用等)：如流程控制(其它语言不同分支可能返回
       不同类型甚至有可能是空指针，但在 Rust 中不同分支必须返回相同类型[更加安全])
    // Rust 表达式即是 Rust 背后暗藏一致性的规则 : Rust 中一切皆表达式，由此引申出 Rust 一切皆类型，因为
       表达式都是会有值的，而值都会产生类型。Rust 就是通过各种类型的系统检查来保证内存安全和并发安全，所以
       对了解 Rust 表达式求值规则十分必要
    // 表达式优先级

 */
fn main() {
    ;
    ;
    ();
    {()}
    {
        ();
        use std::vec::Vec;
    }
    // 带引用操作符的块表达式最终返回块表达式(此处返回单元类型值)的引用
    &{;};       // -> &()
    ;           // -> ()
    // 无法对分号直接引用来获取一个单元值的引用类型 : 可使用块表达式 &{}; 或者 &(); 达成目标
    // &; // 飘红报错()
    &();
    &{};
    // match 表达式
    for i in 0..6{
        match(i%3,i%5){
            // match 分支间使用逗号分隔( Rust 中逗号表示一种顺序 )
            (0,0) => println!("FizzBuzz"),
            (0,_) => println!("Fizz"),
            (_,0) => println!("Buzz"),
            (_,_) => println!("{}",i),
        }
    }
    ;
}

// 块中最后一行不加分号的表达式
fn plus_one(i: &mut u32) -> u32 {
    *i += 1;
    *i          // 隐式返回(亦可使用 return [其惯用法于最后加分号]关键字显式返回)
}

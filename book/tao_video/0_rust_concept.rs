
/*
0. Rust 语言基础(图"img/0_课程内容概述.png")
    a. 所有权机制
    b. 借用和生命周期
    c. 类型系统与 trait
    d. 突破抽象范式
    e. Unsafe Rust
    f. 使用过程中挖掘 Rust 更多的使用技巧和设计模式

1. 语言核心概念讲解
    a. 第一阶段：进一步梳理一遍语法
    b. 第二阶段：讲解核心概念
    c. 第三阶段：异步编程

2. 实战：编写轻量级异步 web 框架
    a. 第一阶段：构建异步框架基本骨架
    b. 第二阶段：为异步框架扩展功能
    c. 第三阶段：使用异步框架和 WebAssembly 技术开发小应用

3. 学习 Rust 的十条最佳建议(一致性规则)
    a. 建议一：从整体出发，不要让自己陷入到细节中去
               (学习需要掌控感：有利于建立知识网络[类比画画：先画轮廓再画细节])
    b. 建议二：抛弃一次性学会的念头，分层次递进式学习
    c. 建议三：和已有知识建立联系(一致性原则)
                Rust 中的 if 条件语句是表达式而非语句(故其返回值类型要求一致)
    d. 建议四：学会阅读源码，从源码中学习
               如学习到 String 知其为 u8 类型的动态数组的，故 u8 字节序列的很多特性都适用于 String
    e. 建议五：通过主题式阅读填补知识空白
               Async/Await
    f. 建议六：时刻把握 Rust 设计哲学
               安全、实用、性能
    g. 建议七：有意识地构建 Rust 语言的心智模型
                心智模型是思想意识在客观世界的延伸(构建与"编译器"一致性心智模型)
    h. 建议八：多分享多提问多交流
                学习最忌讳就是"闭门造车"
    i. 建议九：为开源项目做贡献，锻炼自己
    j. 建议十：阅读《Rust 编程之道》

// robust[rəʊˈbʌst]n.强健的(鲁棒性[即"健壮性"])
4. Rust Logo
    Rust 在字形上糅合了 Trust 和 Robust (暗示了信任与鲁棒性)。Rust 语言的使命从未改变，其设计哲学逐步变得
    更加具体：内存安全为第一准则、注重并发安全并避免数据竞争、持续提升性能、保持语言的高度一致性以及语言必须
    有可见的实用性、注重开发体验与学习体验、拥抱开源社区。基于这些设计哲学，Rust 语言成为一门赋予每个人构建
    可靠且高效软件能力的语言。即
        内存安全为第一准则
        注重并发安全，避免数据竞争
        持续提升性能
        保持语言的高度一致性
        语言必须有可见的实用性
        注重开发体验和学习体验
        现代化语言特性
        拥抱开源社区

5. Rust 语言的内存安全方案针对的是 C 语言的不足。
    a. 禁止对空指针和悬垂指针进行解引用
    b. 读取未初始化的内存
    c. 缓冲区溢出
    d. 非法释放已经释放或未分配的指针(即重复释放)
    // 注：内存泄漏并非 Rust 承诺的安全范围，虽然 Rust 号称内存安全的语言但其并未打算做到百分百的安全，它
           旨在消除非法访问内存的安全隐患(据相关数据统计：世界上约 70% 的安全漏洞都是由非法访问内存引起的)

6. Rust 安全且无缝沟通 C 语言
    a. 通过 C-ABI 零成本和 C 语言打交道
    b. 划分了 Safe Rust 和 Unsafe Rust

7. Rust 是具有混合范式的" 面向过程 "式的编程语言
    a. Rust 包含了 面向对象（OOP）、函数式（FP）和泛型三种编程范式
    b. OOP 和 FP 范式在 Rust 语言中是作为语言特性而存在，并非是抽象方式
    c. Rust 让开发者专注于解决问题本身，而不受编程范式思想框架的干扰

8. Rust 词法结构
    a. 词法结构是编程语言的基础规则(编程语言都必须经过词法分析、语法解析这两个最基本的阶段才能最终被执行)
    b. Rust 编译过程(图"1_Rust 编译过程.png")
       编译过程要经过多道工序：Rust 源码文本作为 UTF-8 编码序列输入到编译器 --(分词)-> 经过分词，把词法
       结构处理为词条流 --(解析)-> 然后词条流经过语法解析形成抽象语法树 AST　--(阶级)-> (大部分语言在形成
       抽象语法树后就会直接转译为字节码或机器码但 Rust 在生成机器码之前还增加了一些工序：首先将抽象语法树
       降级[即进一步简化成高级中间语言 HIR 及中级中间语言 MIR　再交由 LLVM 后端去生成机器码]) HIR --(降级)
       ->(中级中间语言) MIR --(优化)-> LLVM --(优化)->(生成字节码)100100100
       对于编译器而言，所有的版次即 Edition Code 在到达中级中间语言层的时候已经消除了那些版次的差异，即是
       说中级中间语言是多个 Edition

 */
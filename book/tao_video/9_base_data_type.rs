
/*
0. 类型系统
    类型系统将表达式的值归类为具有特定意义的类型，机器码(由"0、1"组成)层面无法分清数据是字符还是整数，所以
    需要使用类型赋予这些字节特定的意义。方便开发者开发，不同的类型有着不同的内存布局，类型间相互作用则可能
    出现错误，造成内存不安全问题，所以一门语言拥有类型系统还不够，还必须做到类型安全。故需梳理类型系统。

1. 类型安全
    Rust 类型系统承载的目标主要包括"保证内存安全、保证一致性、表达明确的语义及零成本抽象表达能力"。为达到
    这四个目标，Rust 类型系统使用了两个相辅相成的概念:" 类型 "( Rust 中一切皆类型：针对不同场景精致地划分
    不同类型，方便编译期对其进行静态分析)及" 行为 "( Rust 通过 Trait 来规范类型的行为，力求做到类型安全)

2. Rust 中的类型
    a. 基本数据类型
    b. 自定义复合类型
    c. 容器类型
    d. 泛型
    e. 特定类型

3. 基本数据类型 (图" 12_基本数据类型.png ")
    a. u8 / i8 : 8 比特(bit)" 无符号/有符号 "整型;
    b. usize / isize : " 无符号/有符号 "指针大小类型
                 (指针大小一般与计算机字长相等[如 32/64 位处理器其指针大小即为 4/8 字节])
    c. bool : 布尔值可转换为数值类型(反之则不行)
    d. 数组 : 目前仍为二等公民，即" [T;2] "与" [T;3] "为不同类型。但等常量泛型功能稳定以后，数组可
              晋升为一等公民(即是可统一为" [T;N] "的类型签名)
    e. 字符 ：Rust 中的字符是一个 Unique 的标量类型(即实际存在的 UNIQUE 字符[占 4 个字节])
    f. 字符串 (图"13_字符串.png") : 体现 Rust 设计精致的一面。Rust 是按照字符串的使用场合进行分类，
       字符串要考虑的场景包括：
            (0). 字面量
            (1). 动态可增长字符串
            (2). 从一段字符串中截取的片段(即"切片")
            (3). 字符串编码
            (4). FFi 中需要转换字符串到 C 或 OS 本地字符串
                 FFI (即外部函数接口[Foreign Function Interface，FFI])
            (5). 遵循特定格式的文件路径
        // 为保证类型系统覆盖到上述等全部场景并保证类型安全，Rust 设置多种字符串类型
    g. 字符串与切片( Rust 中字符串就是 UTF-8 编码的 u8 序列)
        (0). str -> &str : str 类型代表字符串切片类型
             因为 Rust 内存分配默认是在栈上进行分配，并且通过栈来管理堆内存，所以必须在编译期确定类型大小。
             但编译器不可能知道开发者会存储多长的字符串，故此处 str 类型是一个动态大小类型。而字符串切片
             类型最常用的形式就是 str 引用类型即 &str, 这类引用被称为胖指针,表示一个栈上存储指向静态区域
             或者堆内存的指针以及数据的长度(因其比普通指针多占用空间故称其为"胖指针")
        (1). [T] -> &[T] : 如 &[u8]
             对于字面量而言，字符串可存储在静态数据区，栈内存只存储指针，所以它是一个静态引用的字符串切片
             类型(字面量算是一个静态字符串切片)。切片类型代表的是一个连续内存空间的序列，使用" [T] "表示，
             也是一个动态大小类型,比如字符串切片 &[u8] 就是切片类型的一个特例,因为字符串可看作是一段连续
             内存空间的序列。同理编译器不知道程序中会出现多长的切片序列，所以切片类型以胖指针形式表现，如
             &[u8] 序列切片.( u8 序列切片和字符串[亦为字节序列]的区别在于：字符串切片除了是字节序列外还
             表示 UTF-8 编码的合法字符串，字符串切片可安全地转化为 u8 序列，反之则不一定，因为 u8 序列并
             不一定是合法的 UTF-8 编码字节序列)
        (2). String -> Vec<u8> ：动态可增长字符串 str 类型则必须置于堆上，所以它实际上是具有合法 UTF-8
             编码的 u8 动态数组序列，同理 u8 动态数组序列就不一定是合法的。
        // 注: 切片(slice)是一种不持有所有权的数据类型, 其允许引用集合中某一段连续的"元素序列"而非整个集合;
               动态数组(vector)允许连续存储任意多个值：数组 array 及 动态数组 vector 皆可存储结构体对象
               即" [struct; N] 或 vec![s; N] "(N 皆可省略).
        // 注：对数组取借用 borrow 操作可生成一个数组切片(Slice),其对数组没有所有权,可将其看作专门指向数组
               的指针,是对数组的另一个视图。如数组" [T; N] "其借用指针类型" &[T; N] "可通过编译器内部魔法
               转换为数组切片类型" &[T] "。数组切片实质上还是指针，它不过是在类型系统中丢弃了编译阶段定长
               数组类型的长度信息，而将此长度信息存储为运行期的值
        // 注：切片(Slice)类型是对一个数组(包括固定大小数组和动态数组)的引用片段，有利于安全有效地访问部分
               数组而无需拷贝。在底层切片代表一个指向起始位置的指针和数组长度(即"胖指针")，用 [T] 类型表示
               连续序列则切片类型即是" &[T] 或 &mut [T] "
        // 注： DST 和 胖指针：动态大小类型(Dynamic Sized Type; DST)指的是编译阶段无法确定占用空间大小的
                类型，为了安全性指向 DST 的指针一般是胖指针(数组切片是一个指向数组且携带长度信息的胖指针)。
                如对于不定长数组类型 [T] 有对应的胖指针 &[T] 类型；对于不定长字符串 str 类型有对应的胖指针
                &str 类型以及 Trait Objct 等。由于不定长数组类型 [T] 在编译阶段无法判断该类型占用空间大小,
                且目前尚不能在栈上声明一个不定长数组的变量实例，也不能用它作为函数的参数、返回值，但是指向
                不定长数组的胖指针大小是确定的，故 &[T] (一般占用两个指针大小空间)类型可用作变量实例、函数
                参数及返回值。
        // 胖指针内部数据既包含了指向源数组的地址又包含了该切片的长度。对于 DST 类型有如下限制：
           (0). 只能通过指针来间接操作 DST 类型：可用 &[T] 、Box<T> (但 [T] 不行)
           (1). 局部变量和函数参数的类型不能是 DST 类型：因编译阶段必须确定其大小
           (2). enum 中不能包含 DST 类型, struct 中只有最末尾元素可以是 DST，其余位置则不行；若 struct
                包含有 DST 类型那么此结构体也成了 DST 类型。如
                    /* 编译报错：
                  error[E0277]:the size for values of type `str` cannot be known at compilation time
                        name:str,
                             ^^^ doesn't have a size known at compile-time
                    */
                    struct SN{
                        name:str,
                        id:i8,
                    }
                    // 正常编译
                    struct SN{
                        id:i8,
                        name:str,   // DST 置于末尾元素可正常编译(包含 DST 的 struct 亦是 DST 类型)
                    }
      // [自]注: 切片类型是对(动态)数组的引用片段,不持有所有权,故只能间接访问(读取或更新操作)而不能增删元素
                array、slice、vec 间的关系[???]

*/

/*
4. (基本数据类型)指针类型：三种指针类型
    a. 原始指针
        *mut T 和 * const T，这种指针等价于 C 语言里的指针，可以为空，一般用于 Unsafe Rust 中
    b. NonNull 指针
         Rust 语言建议 NonNull 用于替代 *mut T 的指针。NonNull 是非空指针且遵循生命周期类型协变规则。
    c. 函数指针： 函数指针是指向代码的指针，而非数据。可用其直接调用函数

5. (基本数据类型)引用
    a. 两种引用类型：&T 和 &mut T (不可变引用[共享引用]/可变引用[独占引用])
    b. 引用与指针的主要区别：
        (0). 引用不可能为空
        (1). 引用拥有生命周期
        (2). 引用受借用检查器保护不会发生悬垂指针等安全问题

6. (基本数据类型)元组 : 元组是 Rust 中唯一一个可异构(即元组中可存储不同类型的值)的系列
    a. 元组是有长度的，不同长度的元组属于不同类型
    b. 单元类型的唯一实例等价于空元组。
       可将单元类型的值看成是一个"空元组"，但一般都将其作为" 单元类型 "
    c. 当元组只有一个元素的时候，也要在元素末尾加逗号分隔(为方便和括号操作符区分开)

7. (基本数据类型) Never 类型 ：代表的是" 不可能返回值的计算类型 "
    a. Never 类型理论中叫做底类型，底类型不包含任何值但可转换为任何其它类型。Rust 要做到类型安全，就必须把
       程序中所有可能性都纳入类型系统管理之下，包括这些不可能返回值的任何计算(如程序崩溃退出的情况就不可能
       返回任何值)
    b. Never 类型用 ! 叹号(目前还未稳定但在 Rust 内部已经在用),比如 if 表达式 true 分支执行某些事情；else
       分支使用 panic 让线程崩溃，if 表达式分支必须满足类型一致，此时"底类型"就满足了这种情况，故即使 else
       分支会崩溃，不可能返回任何值，但此 if 表达式仍可编译通过

*/
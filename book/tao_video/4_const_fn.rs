
// evaluate[ɪˈvæljueɪt]v.评估,估算
/*
0. Rust 语言的编译期计算:
   Rust 编译期计算支持：常量函数和常量泛型

1. 编译期计算 Rust 支持两种方式：
    a. 过程宏 + Build 脚本（build.rs)
       第一种就是使用过程宏配合 build 脚本，几乎可以在编译时执行任意代码(包括类型计算、生成代码等)。
       // 过程宏虽然亦可编译期求值但不如 CTFE 方式更加通用和方便，比如无法在宏代码及普通代码间共享代码，而
          常量表达式(CTFE)则是可以的，所以支持常量表达式非常重要
    b.  Rust 的 CTFE (compile time function evaluation)：正在完善过程中，Rust 只支持最小化的一个可用子集
        (类似 Cpp 中 constexpr 的 CTFE功能 : C++ 编译期常量表达式求值) Rust 中的常量表达式又分为两大类：
        (0). 常量函数（const fn）
        (1). 常量泛型（const generic）

2. 常量函数（const fn） / 常量表达式与常量上下⽂
    a. 编译期常量函数求值的机制，简言之就是由编译器在编译时(而非运行时)去执行一些常量表达式如
            常量上下文  常量表达式
                  |      |
                  v      v
            const X: T = … ;  // 等号后的表达式要求在编译期可执行即"常量表达式"
    b. 常量上下文（const context）包含：
        (0). 常量值初始化位置
        (1). 静态数组的长度表达式，[T; N]
        (2). 重复的长度表达式，类似于 ：[ 0; 10]
        (3). 静态变量、枚举判别式的初始化位置
        // 常量上下文是编译器唯一进行编译期求值的地方，谨记这一点(即在非常量上下文的地方，常量表达式不一定
           会在编译期求值)
    c. ( Rust 中另一个和常量有关的概念:常量传播)常量函数（const fn）/ 常量传播（Const propagation)，常量
       传播与编译期计算不同：注意不要混淆两者的概念
        (0). 常量传播是编译器的一种优化 :
             如把所有" 3 + 4 "的地方都改成 7 ，避免运行时再次计算
        (1). 常量传播并不能改变程序的任何行为，并且对开发者是隐藏的
        (2). 而编译期计算则是指编译时执行的代码，必须知道其结果，才能继续执行(编译期计算对于开发者来说，它
             是透明的)
             const X: u32 = 3 + 4;  // CTFE (编译期计算)     // 常量声明必须指明"类型"
             let x: u32 = 4 + 3; // 不是 CTFE 但可能会被常量传播优化，因为它不是一个常量上下文

*/
fn main_0() {
    let an = (42, ).0;
    /* 编译错误
      error[E0435]: attempt to use a non-constant value in a constant
        const AN: i32 = an;
                        ^^ non-constant value
     */
    // const AN: i32 = an;      // 常量声明必须指明"类型"
    /* 飘红报错：常量不可重复定义(因常量定义不可更改且全局可用)
       value named `AN` has already been defined in this block [E0428]
     */
    const AN: i32 = (42, ).0;
}

/*
3. 常量函数（const fn） / 常量安全（Const Safe）
    a. Rust 里的大部分表达式都可用作常量表达式。
    b. 并不是所有常量表达式都可以用在常量上下文。
       如一个数组的长度是依赖于磁盘中某个文件长度，但欲知文件长度则必须在运行时去读取，而编译期求值功能仅
       限于在编译期求值，不能引入编译期之外的任何副作用，即使在编译期读取文件也不能保证每次读取到的一定是
       相同的长度，万一文件有变化呢。
    c. 编译期求值必须得到一个确定性的结果。
       这就引入了一个常量安全的问题，这和 Rust 不能引入任何内在错误的目标类似，为了解决这个问题 Rust 引入
       常量函数(类似 C++ 里面的常量表达式求值)
    d. 编译期的计算对性能提升是非常有帮助的：在 Rust 类型系统主要分支上还存在一个子类型系统

 */

// 创建常量函数 gcd ：用于计算最大公约数
const fn gcd(a: u32, b: u32) -> u32 {
    match (a, b) {
        (x, 0) | (0, x) => x,
        (x, y)if x % 2 == 0 && y % 2 == 0 => 2 * gcd(x / 2, y / 2),
        (x, y) | (y, x) if x % 2 == 0 => gcd(x / 2, y),
        (x, y)if x < y => gcd((y - x) / 2, x),
        (x, y) => gcd((x - y) / 2, y),
    }
}

// 将常量函数执行结果赋值于常量 GCD (其计算过程即是在编译期完成)
const GCD: u32 = gcd(21, 7);

// 常量函数支持内部嵌入式定义与递归(如斐波那契数列)
const fn fib(n: u128) -> u128 {
    // 常量函数内嵌常量函数
    const fn helper(n: u128, a: u128, b: u128, i: u128) -> u128 {
        if i <= n {
            // 常量函数递归
            helper(n, b, a + b, i + 1)
        } else {
            b
        }
    }
    helper(n, 1, 1, 2)
}

// 将常量函数执行结果赋值于常量 X (同理其计算过程即是在编译期完成)
const X: u128 = fib(10);

fn main() {
    // 常量函数计算在编译期完成
    println!("GCD = {}", GCD);
    println!("X = {}", X);
}
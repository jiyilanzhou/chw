/*
0. 从表达式的分类角度来看 Rust 的变量绑定和引用
    a. Rust 中表达式的分类
    b. Rust 所有权语义在表达式上的体现
    c. 不可变与可变

1. Rust 中表达式的分类
    a. 位置表达式与值表达式 (图"3_位置表达式与值表达式.png")
       ( Rust 语言未采用其它语言中"左值"与"右值"的术语，而是重新命名为"位置表达式"与"值表达式",其用意非常
       明显，就是在传达一种语义[第一对"位置表达式"求值可得到代表内存位置的值，通过这个值可得到内在地址;第二
       对"值表达式"求值得到的是从属于内存位置的数据本身的值])
    b. 等号左侧的"位置表达式"区域也叫做"位置上下文"，而右侧"值表达式"区域亦称为"值上下文"。表达式的求值既
       依赖于自身的类别也依赖于上下文

2. 表达式背后的内存管理
    c. let 语句(如" let answer = 42; ")赋值的本质(图"4_let 语句赋值的本质.png")
       (0). 位置表达式 answer 得到一个代表位置的值([自]内存地址)，值表达式 42 得到数据值本身后通过位置将
            值 42 存入位置表达式对应的内存地址
       (1). 对于一般操作系统而言，虚拟内存空间大致可分为栈内存、堆内存及静态存储区等，所以数据具体存入的
            区域还需参照值表达式的类型，所以 let 赋值语句中 answer 变量有一个专门的术语即"绑定"，表示把
            内存位置和数据绑定(图"5_let 绑定.png")在一起，并且它拥有对内存位置的管理权

3. 位置表达式(除了 let 赋值语句的位置表达式外，还有其它几个位置表达式如下)
    a. 静态变量初始化
        如：static mut LEVELS: u32 = 0;   // 静态变量是有地址的(区别于常量)
    b. 解引用表达式
        如 *expr : 使用星号" * "对表达式进行解引用
    c. 数组索引表达式
        如 expr[expr]
    d. 字段表达式
        如 expr. field
    e. 以及加上括号的位置表达式，形如 (expr)
    // 除此之外的都是值表达式

4. 位置上下文(除赋值左侧的位置上下文外还有如下"位置上下文")：
    a. 复合赋值操作的左侧
       let mut a = 1;
       a += 1           // 复合同仁操作 +=  (其左侧的" a "即是位置上下文)
    b. 一元"借用"和"解引用"操作中的操作数所在区域
        let a = & mut 7;        // 定义" let a "一个对数字的可变借用，其右侧属于位置上下文
        *a = 42;        // *a 为解引用操作，其代表的亦是位置上下文
    c. 字段表达式的操作数所在区域
        struct A {
            name : &static str,
        }
        let a = A{name : "Alex"}
        a.name;     // field expr       // " . "后面的属性(字段所在区域)即位置上下文
    d. 数组索引表达式的操作数所在区域
        let mut a = [1,2,3];
        let b = &mut a;
        a[1] = 42;              // [1,42,3]         // 左侧使用索引的" a[1] "即位置上下文
    e. 任意隐式借用操作数所在区域
        let mut v = vec![1,2,3];
        v.push(4);  // push 方法调用会隐式借用 &mut v (因 push 方法首参数为" &mut self ")
    f. let 语句初始化
        let a : i32;    // 初始化但并未赋值，则初始化位置即属于一个位置上下文
        a = 42;
    g. if let / while let/ match 的匹配表达式所在区域
        let dish = ("Ham","Eggs");
        if let ("Bacon", b) = dish {     // 匹配表达式 ("Bacon", b) 所在区域就是位置上下文
                                         // 通过得到内存位置上的" Ham "和" Bacon "进行比较
            println!("Bacon is served with {}", b);
        } else {
            println!("No bacon will be served");
        }
        // 同理
        // while let (位置上下文) = ... { ... }
        // match (位置上下文) = ... { ... }
    h. 结构体更新语法中的 base 表达式（" .. "操作符后面的操作数区域）
        let mut base = Point3d {x:1, y:2, z:3};
        let y_ref = &mut base.y;
        Point3d {y:0, z:10, .. base};     // 得到 base.x (即仅更新 y,z 而保留 x 的值）
                                          // " ..base "即是位置上下文
    // 除上述 8 种情况外其余都属于值上下文

 */
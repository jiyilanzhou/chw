
// homogengeous[ˌhɒməˈdʒiːniəs]adj.均匀的,同质的
/*
0. Rust 的面向对象编程特性
  面向对象编程(Object-Oriented Programming，OOP)是一种对程序建模的方法

1. 使用 trait 对象来存储不同类型的值(p502[*])
    a. 为共有行为定义一个 Draw trait(内含 draw 方法)，接着便可定义一个持有 trait 对象的
       动态数组。trait 对象能够指向一个实现了指定 trait 的类型实例，以及一个用于在运行时
       查找 trait 方法的表。通过选用一种指针，如 & 引用或 Box<T> 智能指针等，并添加 dyn
       关键字与指定相关 trait 来创建 trait 对象[第19章"动态大小类型和 Sized trait "一节
       中会介绍"必须使用指针来创建 trait 对象的原因"])。trait 对象可被用在泛型或具体类型
       所处的位置。任何使用 trait 对象的位置，Rust 类型系统会在编译时确保在相应位置上的值
       实现 trait 对象指定的 trait。因此无需在编译时知晓所有可能的具体类型
    b. 亦可使用带有 trait 约束的泛型参数来定义结构体，但其工作机制与 trait 对象不同。泛型
       参数一次只能替代为一个具体的类型(参阅"单态化")，而 trait 对象则允许在运行时填入多种
       不同的具体类型。如"使用泛型参数与 trait 约束"来定义结构体：
            pub struct Screen<T:Draw>{
                // 同质集合
                pub components: Vec<T>, // 只能存储实现了 Draw trait 的单一具体类型
            }
       // 注：若仅需要"同质集合(homogeneous collection)"，那么使用泛型和 trait 约束再好
              不过(因为这段定义会在编译时被多态化以便使用具体类型)
    c. 实现 trait
        使用 trait 对象与类型系统来实现"鸭子类型(duck typing)"有一个明显优势：永远不需要
        在运行时检查是否实现了指定的方法，或者担心出现"调用未定义方法"等运行时错误，因为
        Rust 根本就不会允许这样的代码通过编译。

*/
pub trait Draw {
    fn draw(&self);
}
// 带有 components 字段的 Screen 结构体定义
pub struct Screen {
    // components 字段存储实现了 Draw trait 的 trait 对象动态数组
    pub components: Vec<Box<dyn Draw>>, // 存储实现了 Draw trait 的具体类型(多种类型)
}

/*
2. trait 对象会执行动态派发(p509[*])
    a. Rust 编译器会在泛型使用 trait 约束时执行单态化：编译器会为每一个具体类型生成对应
       泛型函数和泛型方法的非泛型实现，并使用这些具体的类型来替换泛型参数。通过单态化生成
       的代码会执行静态派发(static dispatch)，意味着编译器能够在编译过程中确定调用的具体
       方法(与"动态派发"相对应)
    b. 动态派发(dynamic dispatch)下的编译器无法在编译过程中确定调用的具体方法。在进行动态
       派发的场景中，编译器会生成一些额外的代码以便在运行时找出预期调用的方法
    c. Rust 必然会在使用 trait 对象时执行动态派发。因为编译器无法知晓所有能够用于 trait
       对象的具体类型，所以它无法在编译时确定需要调用哪个具体类型的方法。不过，Rust 会在
       运行时通过 trait 对象的内部指针去定位具体调用的方法，该定位过程会产生一些不可避免
       的运行时开销，而这不会出现在静态派发中。动态派发还会阻止编译器内联代码进而使得部分
       优化操作无法进行。但不管怎样，动态派发为设计带来了额外的灵活性(按需考虑使用)

3. trait 对象必须保证对象安全(p510[?])
    a. 需要注意的是，只能把满足对象安全(object-safe)的 trait 转换为 trait 对象。Rust 采用
       一套较为复杂的规则来决定某个 trait 是否对象安全。但在实际开发中，只需要关注其中两条
       规则即可。若一个 trait 中定义的所有方法满足以下两条规则那么此 trait 就是对象安全的：
       (0). 方法的返回类型不是 Self
       (1). 方法中不包含任何泛型参数
       // 关键字 Self 是一个别名，它指向了实现当前 trait 或方法的具体类型
    b. trait 对象必须是对象安全的，因为 Rust 无法在使用 trait 对象时确定实现这个 trait 的
       具体类型，所以编译器无法在 trait 方法返回 Self 时使用原来的具体类型。同理对于 trait
       方法中的泛型参数而言，会在使用时将具体类型填入泛型所处位置，这些具体类型会被视作当前
       类型的一部分。但使用 trait 对象时其具体类型信息被抹去故无法确定填入泛型参数的类型([?])
    c. 标准库提供的一个不符合对象安全的典例：Clone trait
           pub trait Clone {
               fn clone(&self) -> Self;
           }

4. 实现一种面向对象的设计模式
    a. 状态模式(state pattern)是一种面向对象设计模式。该模式的关键特点是，一个值拥有的内部
       状态由数个状态对象(state object)表达而成。而值的行为则随着内部状态的改变而改变。这种
       设计模式会通过状态对象来共享功能：相对应地，Rust 使用结构体与 trait 而非"对象和继承"
       来实现这一特性。每个状态对象都会负责自己的行为并掌控自己转换为其它状态的时机。而持有
       状态对象的值则对状态的不同行为和状态转换的时机一无所知。
    b. 使用状态模式意味着在业务需求改变时无需修改持有状态对象的值或者使用这个值的代码，只需
       更新状态对象的代码或增加一些新的状态对象，就可以改变程序的运转规则。

5. 状态模式的权衡取舍(p521[*])
    a. 优势
        可根据状态来封装不同类型的行为
    b. 弊端
        (0). 因为状态实现了状态间的转移，所以某些状态是相互耦合的
        (1). 需重复实现一些代码逻辑，虽可使用 trait 的默认实现但却违背对象安全规则(不推荐)

6. 小结
    动态派发通过牺牲些许的运行时性能赋予了代码更多的灵活性

*/
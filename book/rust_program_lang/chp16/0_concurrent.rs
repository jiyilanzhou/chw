
// guard[ɡɑːd]v&n.守卫，保护     // spawn[spɔːn]n.繁衍
/*
0. 无畏并发

1. 使用线程同时运行代码(p466)
    a. " 1:1 "模型：直接利用操作系统 API 来创建线程的模型
    b. " M:N "模型：由程序语言提供、自身特有的线程
    c. Rust 标准库仅提供 1:1 线程模型实现( M:N 线程模型可参阅 Rust 社区)

2. 使用 Spawn 创建线程(p467[*])
    可调用 thread::spawn 函数来创建线程，它接收一个闭包作为参数。该闭包内含想要在
    新线程中运行的代码

3. 使用消息传递在线程间转移数据
   通道的接收端有两个可用于获取消息的方法: recv 和 try_recv。recv (receiver 缩写)
   会阻塞主线程的执行直到有值被传入通道，一旦通道有值传入通道， recv 就会将它包裹在
   Result<T,E>中返回，而如果通道的发送端全部关闭了，recv 则会返回一个错误来表明当前
   通道再也没有可接收的值；try_recv 不会阻塞线程，它会立即返回 Result<T,E>，当通道
   中存在消息时，返回包含该消息的 OK 变体否则返回 Err 变体，当某个线程需要一边等待
   消息一边完成其它工作时 tre_recv 方法会非常有用(可编写一个不断调用 try_recv 方法
   的循环并在有消息到来对其进行处理而在没有消息时执行其它命令)

4. 通过克隆发送者创建多个生产者
   let (tx.rx) = mpsc::channel();
   let tx_clone = mspc::Sender::clone(&tx);

5. 共享状态的并发
   从某种程度上来说，任何编程语言中的通道都有些类似单一所有权的概念，因此不应该在值
   传递给通道后再次使用它

6. 多线程与多重所有权(p490)
    a. 借助于智能指针 Rc<T> 提供的引用计数为单个值赋于多个所有者。故可用 Rc<T> 来
       包裹 Mutex<T> 并在每次需移动所有权至线程时克隆 Rc<T> (无法在线程间安全传递：
       其未使用任何并发原语来确保修改计数的过程中不会被其他线程中断，从而产生 bug )
    b. Arc<T> 是一个既拥有类似于 Rc<T> 的行为，又保证可安全用于并发环境的类型

7. 使用 Sync trait 和 Send trait 对并发进行扩展(内置于" std::marker "模块)
    a. Send trait : 允许线程间转移所有权
       除了 Rc<T> (单线程)等极少数类型外几乎所有的 Rust 类型都实现了 Send trait；
       除了 19 章将会讨论的裸指针，几乎所有的原生类型都满足 Send 约束
    b. Sync trait ：允许多线程同时访问
       只有实现了 Sync trait 的类型才可以完全地被多个线程引用。与 Send 类似，所有原生
       类型都满足 Sync 约束(智能指针 Rc<T> 同样不满足 Sync 约束，RefCell<T> 类型及
       Cell<T> 系列类型也不满足 Sync 约束，RefCell<T> 实现的运行时借用检查并没有提供
      有关线程安全的保证。而智能指针 Mutex<T> 是 Sync 的可用于多个线程访问)
    c. 手动实现 Send 和 Sync 是不安全的

8. 小结
   Rust 在标准库中提供了用于实现消息传递的通道，也提供了可以在并发场景中安全使用的智能
   指针：Mutex<T> 及 Arc<T>。类型系统与借用检查器则确保使用这些组件的代码不会产生数据
   竞争或无效引用。

*/
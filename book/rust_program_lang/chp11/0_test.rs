
/*
0. 编写自动化测试
   编写测试用例进行断言，并利用" 断言 "确保所有已经存在的正确行为不会受到
   改动的影响。且将测试用例组织为单元测试与集成测试

1. 如何编写测试
    a. Rust 语言中的测试是一个函数，用于验证非测试代码是否按照期望的方式运行。
    b. 测试函数的函数体一般包含 3 个部分：
        (0). 准备所需的数据或状态
        (1). 调用需要测试的代码
        (2). 断言其结果是所期望的
    // 测试代码的相关功能：包含 test 属性、一些测试宏和 should_panic 属性

2. 测试函数的构成
    a. 最简情况下 Rust 中的测试是一个标注有 test 属性的函数。属性(attribute)
       是一种修饰 Rust 代码的元数据(如" 结构体上方关联的 derive 属性 ")
    b. 将" #[test] "添加到关键字 fn 的上一行便可以将函数转为测试函数，当测试
       编写完毕可用" cargo test "命令来运行测试
    c. 使用 Cargo 新建一个库项目时会自动生成一个带有测试函数的测试模块(有助于
       启动新项目时开始编写测试代码[可额外增加任意多的测试函数以及测试模块])

3. 使用 assert! 宏检查结果
   可接收一个能够被计算为布尔类型的值作为参数

4. 使用 assert_eq! 宏和 assert_ne! 宏判断相等性
   a. 可利用 assert! 宏向其中传入一个使用" == "运算符的表达式来完成，因此项测试
      常见，故标准库专门提供了一对可简化编程的宏:" assert_eq! / assert_ne! "。
   b. 使用" assert_eq! "或" assert_ne! "宏断言失败时会打印出这具体值(便于观察
      测试失败原因[溯源]）而" assert! "只能得知 == 表达式中失败的事实而无法知晓
      被用于比较的值
   c. 在某些语言或测试框架中，这两个被用于相等性判断的参数常常被命名为 expected(
      期望值)和 actual(实际值)

5. 添加自定义的错误提示信息(p287[*])
   可自定义错误信息并将其作为可选参数传入 assert! 、assert_eq! 和 assert_ne! 宏

6. 使用 should_panic 检查 panic
    a. 除检查代码是否返回期望的正确值外，检查代码是否按照预期错误处理亦很重要。
       如" 超出范围数据 "的处理
    b. 可通过对测试函数额外增加属性 should_panic 来实现(标记此属性的测试函数代码
       会在 panic 时通过未 panic 时失败)

7. 使用 Result<T,E> 编写测试
   a. 不要在使用 Result<T,E> 编写的测试上标注 #[should_panic]，在测试运行失败时应
      直接返回一个 Err 值
   b. 编写测试来返回 Result<T, E> 就可在函数体中使用问号运算符，这样可以方便编写在
      任意一个步骤返回 Err 值时都会执行失败的测试

8. 控制测试的运行方式
   a. 同样可通过指定命令行参数来改变 cargo test 的默认行为
   b. 既可为 cargo test 指定命令行参数，亦可为生成的测试二进制文件指定参数。为区分
      两种不同类型的参数，需要在传递给 cargo test 的参数后使用分隔符 -- ,并在其后
      指定需要传递给测试二进制文件的参数。比如运行" cargo test --help "命令会显示
      出" cargo test "的可用参数而运行" cargo test -- --help "则会显示出所有可以
      用在 -- 之后的参数

9. 并行或串行地进行测试
   若不希望测试并行运行或更加精确控制线程数量可传递" --test-threads "参数及线程数量
   给测试生成的二进制文件如" $ cargo test -- --test-threads=1 " (将测试线程设置为
    1 即告知程序不使用并行机制，但会比并行运行花费更多时间，然顺序执行的测试不会因为
   共享状态而出现可能干扰)

10. 显示函数输出(p296[*])
   a. 默认情况下当测试通过时，Rust 测试库会截获打印到标准输出的所有内容(如在测试中
      调用 println! 但若测试通过则不会在终端显示 println! 输出[仅显示测试通过]);
      测试失败才会显示所有标准输出的内容及错误信息
   b. 期望测试通过时也将值打印出来，则可传入" --nocapture "标记来禁用输出截获功能
      即" cargo test -- --nocapture "

11. 只运行部分特定名称的测试
    执行全部的测试用例有时会花费很长时间，可通过向 cargo test 传递测试名称来指定需
    运行的测试(亦可通过模块名来运行特定模块内的测试)

12. 通过显式指定来忽略某些测试
    可用" #[ignore] "属性标记比较耗时的测试，从而将其排除在正常的测试运行之外。但
    亦可用" cargo test -- --ignore "来单独运行这些被忽略的测试

13. 测试的组织结构(p303)
    单元测试(unit test)和集成测试(integration test)：单元测试小而专注，每次只单独
    测试一个模块或私有接口；而集成测试完全位于代码库之外，和正常从外部调用代码库一样
    使用外部代码，只能访问公共接口，并且在一次测试中可能会联用多个模块

*/
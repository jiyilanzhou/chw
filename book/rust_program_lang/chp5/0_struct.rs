
/*
0. 使用结构体来组织相关联的数据

1. 定义并实例化结构体
   结构体实例一旦声明则实例中所有字段都将是可变的。Rust 不允许单独声明
   某一部分字段的可变性

2. 没有任何字段的空结构体
   因没有任何字段的结构体与空元组 () 相似,故称其为"空结构体"

3. 结构体数据的所有权
   struct User{
        /* 使用自持所有权的 String 类型(而非 &str 字符串切片类型)，
           这是一个有意为之的选择，因为我们希望结构体的实例拥有自身
           全部数据的所有权，此种情况下，只要结构体实例是有效的那么
           其携带的字段数据(如"username")亦是有效的
        */
        username: String，

        // 亦可在结构体中存储指向其它数据的引用(涉及生命周期)
        // 生命周期保证结构体实例引用数据的有效期不短于实例本身
        // email: &str
   }

4. 定义方法(p124[***])
   a. 若既不用获取数据的所有权亦无需写入数据而只需读取则选择使用 &self
   b. 欲调用方法时改变实例的某些数据则需将第一个参数改写为 &mut self
   c. 通常而言，将第一个参数标记为 self 并在调用过程中取得实例所有权的
      方法([自]即" mut self ")并不常见。这种技术有可能会被用于那些需要
      将 self 转换为其他类型，且在转换后想要阻止调用者访问原始实例的场景

5. 运算符" -> "到哪里去了[p126[*])
    a. 在 C/C++ 中调用方法时有两个不同的运算符，分别是直接用于对象本身的
       " . "及用于对象指针的" -> "。之所以有这样的区别，是因为在调用指针
       的方法时首先需要对该指针进行解引用。换句话说假如 object 是一个指针
       那么"object->something()"的写法实际上等价于"(*object).something()"
    b. 虽然 Rust 没有提供类似的" -> "运算符，但设计了一种"自动引用及解引用"
       的功能作为代替。方法调用是 Rust 中少数几个拥有这种行为的地方之一。其
       工作模式如下：当使用" object.something() "调用方法时，Rust 会自动为
       调用者添加" &、&mut 或 * "以使其符合方法的签名
    c. 因为方法有一个明确的作用对象：self 的类型。在给出调用者和方法名的前提
       下，Rust 可以准确地推导出方法是否是只读的(&self)，是否需要获取数据的
       所有权(self)，是否需要修改数据(&mut self)。如" p1.distance(&p2); "
       等价于" (&p1).distance(&p2); "(自动解引用)

6. 关联函数
    定义于 impl 块不接收 self 作为参数且与结构体相关联的函数。关联函数常用作
    " 构造器 "来返回一个结构体的新实例

*/

/*
0. 智能指针(p415[*])
    a. 指针(pointer)是一个包含内存地址变量的通用概念(地址指向数据),Rust中最常见的指针是
       引用(reference),引用以"&"符号为标志并借用其所指向的值,除引用数据没有任何其他特殊
       功能也没有任何额外开销，它是 Rust 中最为常见的一种指针
    b. 智能指针(smart pointer)是一类数据结构,其行为类似指针但拥有额外的元数据和附加功能
    c. 在拥有所有权和借用概念的 Rust 中,引用和智能指针之间另一个区别：引用是只借用数据的
       指针,而与之相反地，大多数智能指针本身就拥有它们指向的数据
    d. 智能指针如" String、Vec<T> "(因其拥有内存且允许操作),其还具有元数据(如容量)，并
       提供额外功能或保障(例如 String 确保其数据必定是有效的 UTF-8 编码）
    e. 智能指针通常使用结构体实现,智能指针与普通结构体的区别在于智能指针实现了Deref和Drop
       特性,Deref trait允许智能指针结构体实例的行为类比引用,因此可编写同时用于引用或智能
       指针的代码；Drop trait允许自定义当智能指针离开作用域时运行的代码
    f. 标准库中最为常见的智能指针：
       Box<T> ：可用于在堆上分配值
       Rc<T> ：允许多重所有权(即数据可有多个所有者)的引用计数类型
       Ref<T> 及 RefMut<T>:通过RefCell<T>访问,一种在运行(而非编译)时执行借用规则的类型
       // 将涉及内部可变性(interior mutability)模式(不可变类型暴露能够改变其内部值的API)

1. 使用 Box<T> 在堆上分配数据(p417[*])
   a. 装箱(box)是最为简单直接的一种智能指针，其类型被写作"Box<T>"。装箱使得可将数据存储于
      堆上并在栈中保留一个指向堆数据的指针。
   b. 除数据储存于堆上而非栈上外,装箱没有任何性能开销但也未提供太多额外功能,多用于如下场景：
      (0)当拥有一个无法在编译时确定大小的类型，但又想要在一个要求固定尺寸的上下文中使用这个
         类型的值时。
      (1)当需要传递大数据所有权，但又不希望产生大数据的复制行为时。
      (2)当希望拥有一个实现了指定 trait 的类型值，但又不关心具体类型时。

2. 使用 Box<T> 在堆上存储数据
   装箱被释放时除了存储于栈上的指针，还有其指向的堆空间数据亦被释放

3. 通过 Deref trait 将智能指针视作常规引用(p423[*])
   实现 Deref trait 使得可自定义解引用运算符(dereference operator 即" * ")的行为

4. 函数和方法的隐式解引用转换
   a. 解引用(dereference coercion)是 Rust 为函数和方法的参数提供的一种便捷特性。当某个
      类型 T 实现了 Deref trait 时，它能够将 T 的引用转换为 T 经过 Deref 操作后生成的
      引用。当将某个特定类型的值作为参数传递给函数或方法，但传入的类型与参数类型不一致时，
      解引用转换就会自动发生。编译器会插入一系列的 deref 方法调用来将提供的类型转换为参数
      所需的类型。
   b. Rust 通过解引用转换功能，使得在调用函数或方法时无须多次显式地使用" * 及 * "运算符
      来进行引用和解引用操作。这一特性亦使得可以更好地编写出能够同时作用于常规引用和智能
      指针的代码
   c. 只要代码涉及的类型实现了 Deref trait，Rust 就会自动分析类型并不断尝试插入解引用即
      " Deref::deref "来获得与参数类型匹配的引用。因为这一分析会在编译时完成，所以解引用
      转换不会在运行时产生任何的性能开销。

5. 解引用转换与可变性(p430[?])
   a. 使用 Deref trait 能够重载不可变引用的 * 运算符。与之类似，使用 DerefMut trait 能够
      重载可变引用的 * 运算符
   b. Rust 会在类型与 trait 满足下面 3 种情形时执行解引用转换
      (0). 当 T : Deref< Target = U > 时，允许 &T 转换为 &U
      (1). 当 T : DerefMut< Target = U > 时，允许 &mut T 转换为 &mut U
      (2). 当 T : Deref< Target = U > 时，允许 &mut T 转换为 &U
      // 前两种情形除可变性之外是完全相同的。其中情形之一意味着：如果 T 实现了类型 U 的
         Deref trait，那么 &T 就可以被直接转换为 &U；情形二意味着同样的解引用转换过程会
         作用于可变引用；
      // 情形三有些微妙：Rust 会将一个可变引用自动转换为一个不可变引用，但这个过程绝不会
         逆转，也就是说不可变引用永远不可能转换为可变引用。因为按照借用规则，如果存在一个
         可变引用，那么它就必须是唯一的引用(否则程序就无法通过编译)。将一个可变引用转换为
         不可变引用肯定不会破坏借用规则，但将一个不可变引用转换为可变引用则要求这个引用须
         是唯一的，而借用规则无法保证这一点。因此 Rust 无法将不可变引用转换为可变引用视作
         一个合理的操作。

6. 基于引用计数的智能指针 Rc<T>
   Rust 提供 Rc<T> 来支持多重所有权(Reference counting：引用计数)

7. 使用 Rc<T> 共享数据
   " a.clone() "与" Rc::clone(&a) "调用的是同一方法(但" Rc::clone "方法区别于绝大多数
   类型的"clone"方法，即绝大多数类型的 clone 方法实现的是对所有数据进行深层次拷贝)。调用
   " Rc::clone "只会增加引用计数(而不会深度拷贝)，因此在引用计数上调用 Rc::clone 可以让
   开发者一眼就能区分开" 深度拷贝 "与" 增加引用计数 "这两种完全不同的克隆行为。

*/
enum List {
    Cons(i32, Rc<List>),
    Nil,
}
use crate::List::{Cons, Nil};
// 需用 use 语句将 Rc<T> 引入作用域(因其不在 prelude 中)
use std::rc::Rc;
// 使用 Rc<T> 定义的 List
fn main_0_0() {
    // 创建存放 5 和 10 的列表并将其存放在 a 的新 Rc<List> 中
    let a = Rc::new(Cons(5,
                         Rc::new(Cons(10,
                                      Rc::new(Nil)))));
    /*
   (0). 创建b和c时调用"Rc::clone"函数并传递a中"Rc<List>"的引用作为参数
   (1). 亦可调用"a.clone()"但Rust习惯使用"Rc::clone"(其并非像大部分类型的"clone"实现那样对
        所有数据进行深拷贝),"Rc::clone"只会增加引用计数故不会花费多少时间而深拷贝可能会花费
        很长时间。通过"Rc::clone"进行引用计数可明显区别深拷贝类的克隆和增加引用计数类的克隆,
        当查找代码中的性能问题时只需考虑深拷贝类的克隆而无需考虑"Rc::clone"调用
    */
    let b = Cons(3, Rc::clone(&a));
    let c = Cons(4, Rc::clone(&a));
}

/*
8. 克隆 Rc<T> 会增加引用计数
   Rc<T> 通过不可变引用使得可在程序不同部分之间共享只读数据

9. RefCell<T> 和内部可变性模式(p440[*])
  内部可变性(Interior mutability)是 Rust 的设计模式之一，允许在只持有不可变引用的前提下对
  数据进行修改；通常而言，类似的行为会被借用规则所禁止。为了能够改变数据，内部可变模式在它的
  数据结构中使用了 unsafe(不安全) 代码来绕过 Rust 正常的可变性和借用规则。RefCell<T> 即是
  一个内部可变性模式

10. 使用 RefCell<T> 在运行时检查借用规则(p441[*])
    a. 与 Rc<T> 不同，RefCell<T> 类型代表了其持有数据的唯一所有权(Box<T>亦只有一个所有者 )，
       而 RefCell<T> 和 Box<T> 区别如下：
       (0). 对于使用一般引用和 Box<T> 的代码，Rust 会在编译阶段强制代码遵守这些借用规则。而
           对于使用 RefCell<T> 的代码 Rust 则只会在运行时检查这些规则,并在出现违反借用规则
           的情况下触发 panic 来提前中止程序。
       (1).将借用规则的检查放在编译阶段有许多优势：它不仅会帮助在开发阶段尽早地暴露问题，且
           不会带来任何运行时开销，因为所有检查都已经执行完毕。因此在编译期检查借用规则对于
           大多数场景而言都是最佳的选择，这也正是 Rust 将编译期检查作为默认行为的原因。
    b. 在运行时检查借用规则，可适用于实现某些特定内存安全的场景(即使场景无法通过编译时检查)，
       RefCell<T> 正是用于" 编译器不能理解代码但开发者可以保证借用规则能够满足 "的场景。与
       Rc<T> 类似，RefCell<T> 只能用于单线程场景。
    c. 选择使用 Box<T>、Rc<T> 还是 RefCell<T> 的依据：
       (0). Rc<T> 允许一分数据有多个所有者；而" Box<T>、RefCell<T> "都只有一个所有者
       (1). Box<T> 是允许在编译时检查的可变或不可变借用，Rc<T> 是仅允许编译时检查的不可变
            借用，RefCell<T> 是允许运行时检查的可变或不可变借用。
       (2). 由于 RefCell<T> 允许在运行时检查可变借用，所以即便 RefCell<T> 本身是不可变的，
            但仍然能够更改其中存储的值
       // 内部可变性模式允许用户更改一个不可变值的内部数据(如示例 15-22[p448]:在保持外部值
          不可变的前提下，使用 RefCell<T> 来修改内部存储的值)

11. 内部可变性：可变地借用一个不可变的值(p442[*])
    借用规则的一个推论是：无法可变地借用一个不可变的值。然而在某些特定情况下，亦需要一个值
    在对外保持不可变性的同时能够在方法内部修改自身(除了这个值本身的方法，其余的代码则依然
    不能修改这个值)。使用 RefCell<T> 就是获得这种内部可变性的一种方法。不过，RefCell<T>
    并没有完全绕开借用规则，虽然使用内部可变性通过了编译阶段的借用检查，但借用检查的工作
    仅仅是被延后到了运行阶段，若违反借用规则则会得到一个 panic! 而不再只是编译时的错误。

*/
fn main_0_1() {
    let x = 5;
    //let y = &mut x;// 飘红报错：Cannot borrow immutable local variable `x` as mutable
    /* 编译错误:
       error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
        let x = 5;
            - help: consider changing this to be mutable: `mut x`
        let y = &mut x;// 飘红报错：Cannot borrow immutable local variable `x` as mutable
                ^^^^^^ cannot borrow as mutable
    */
}

/*
12. 使用 RefCell<T> 在运行时记录借用信息
    a. 创建不可变和可变引用时可分别使用语法 & 与 &mut，而对于 RefCell<T> 而言则需要使用
       borrow 及 borrow_mut 方法来实现类似功能。borrow、borrow_mut 分别返回 Ref<T> 及
       RefMut<T> 这两种智能指针。
    b. RefCell<T> 会记录当前存在多少个活跃的 Ref<T> 及 RefMut<T> 智能指针，每一次调用"
       borrow "方法时，RefCell<T> 会将活跃的不可变借用计数加 1，并且在任何一个 Ref<T>
       的值离开作用域被释放同时不可变借用计数减 1 (在任何时候只允许有多个不可变借用或一个
       可变借用)

13. 将 Rc<T> 和 RefCell<T> 结合使用来实现一个拥有多重所有权的可变数据
    a. 将 RefCell<T> 和 Rc<T> 结合使用是一种很常见的用法。Rc<T> 允许多个所有者持有同一
       数据，但只能提供针对数据的不可变访问。若在 Rc<T> 内存储 RefCell<T> 则可以定义出
       拥有多个所有者且能够进行修改的值了
    b. 标准库还提供了其他一些类型来实现内部可变性，例如与 RefCell<T> 十分类似的 Cell<T>,
       但相较于"前者通过借用来实现内部数据的读写",Cell<T> 选择了通过复制来访问数据；另外
       Mutex<T> 被用于实现跨线程情况下的内部可变性模式。

14. 循环引用会造成内存泄漏
    Rust 提供的内存安全保障使得难以在程序中意外地制造出永远不会得到释放的内存空间(也就是
    所谓的内在泄漏 memory leak),但并非不可能

15. 使用 Weak<T> 代替 Rc<T> 来避免循环引用
    a. 可通过调用 Rc::clone 来增加 Rc<T> 实例的 strong_count 引用计数并指出 Rc<T> 实例
       只有在 strong_count 为 0 时才会被清理；亦可以通过调用 Rc::downgrade 函数来创建出
       Rc<T> 实例中值的"弱引用(weak reference)",调用 Rc::downgrade 会返回 Weak<T> 类型
       的智能指针。
    b. 强引用可用来共享一个 Rc<T> 实例的所有权，但弱引用并不表达所有权关系(其不会造成引用
       循环[因任何弱引用的循环会在其相关的强引用计数为 0 时被打破])

*/
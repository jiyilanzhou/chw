
/*
0. 内存管理
   a.手动内存管理
        (1). 需开发者手动使用 malloc 和 free 等函数显式管理内存(如 C 语言)
        (2). 产生问题：内存泄露、悬垂指针(Dangling Pointer)
   b.自动内存管理
        (1). 使用 GC (Garbage Collection,垃圾回收)对内存进行自动化管理(如
             Java、C#、Ruby、Python 等)
        (2). 产生问题：性能问题("世界暂停": GC 在工作时须保证程序不会引入新
             垃圾故要使运行中的程序暂停，这就造成了性能问题)

4.1 通用概念( p95 ~ 96 )
    a. 虚拟地址空间：分为" 用户空间 "及" 内核空间 "，其比例是" 3 : 1 (Linux系统) "
       或" 2 : 2 (Windows系统) "。以 Linux 系统为例 32 位计算机地址空间大小是 4G
       寻址范围是" 0x0000 0000 ~ 0xFFFF FFFF "
    b. 用户空间中的栈(stack)和堆(head) : 栈向下(由高地址向低地址)增长，堆向上(由低
       地址向高地址)增长。如此设计是为了更加高效使用内存
       // 注: 栈和堆"增长"方向取决于"操作系统及中央处理器(CPU)"

4.1.1 栈 ( p96 ~ p99 [*] )
    栈一般有两种定义：一种指数据结构(特殊线性表)，另一种指栈内存
    栈帧: 存储函数调用所需的记录单元

4.1.2 堆 ( p99 ~ p101 [*] )
    a. 堆(heap)一般亦有两种定义：
       一种指数据结构(树型结构[完全二叉树]：其特点为"大顶堆或小顶堆[一般用于排序或
                                         优先队列]")，另一种指堆内存
       // 注：实际工作中对于事先知道大小的类型可分配到栈中(如"固定大小的数组")，但若
              需要动态大小的数组则需要使用"堆内存"
    b. 堆分配算法：空闲链表(Free List)和位图标记(Bitmap)
    c. 访问性能：堆分配算法再好也只是解决堆内存合理分配及回收的问题，其访问性能远不如
       栈内存。存放于堆空间的数据要通过存放于栈空间的指针进行访问，其至少多了一层跳转，
       故能置于栈上的数据最好还要放于栈上。因此 Rust 的类型默认置于栈空间

4.1.3 内存布局 ( p101 ~ p103 [*] )
    a. 内存对齐规则：为权衡空间占用及访问效率

4.2 Rust 中的资源管理
4.2.1 变量和函数(p103 ~ p106[*])
    a. 全局变量
        (1). 常量变量
            常量使用 const 关键字定义且需要显式指明类型。常量没有固定的内存地址，因其
            生命周期是全局的，随程序消亡而消亡且被编译器有效地关联到每个按需使用的地方
        (2). 静态变量
            静态变量使用 static 关键字定义，需显式指明类型(类比常量)，静态变量的生命
            周期亦是全局的但其不会被内联，每个静态变量都有一个固定的内存地址
        // 注：静态变量并非被分配到栈中也不是堆中，而是和程序代码一起被存储于"静态存储
               区"中。(静态存储区是伴随着程序二进制文件的生成[编译时]被分配的,且在程序
               的整个运行期都会存在[如"字符串字面量"即是存储于静态内存中])
    b. 局部变量
         函数内定义的变量
    c. 智能指针
        智能指针可让 Rust 利用栈来隐式自动释放堆内存，从而避免显式调用 free 之类的函数
        去释放(更加便于开发)

4.2.2 智能指针与 RAII (p103~p110[*])
    a. Rust 中的指针大致可分为三种：引用(普通指针)、原生指针(裸指针)及智能指针
    b. 引用与原生指针异同
        (1). 可通过 as 操作符随意转换
        (2). 原生指针可在 unsafe 块下使用(不受 Rust 安全检测规则限制)；而引用则必须
             受编译器安全检查规则限制
    c. 智能指针
        智能指针(smart pointer) 实际上是一种结构体，只不过其行为类似指针。智能指针对
        指针的一层封装，提供一些额外功能比如自动释放堆内存。智能指针区别于常规结构体
        在于其实现了 Deref、Drop 这两个 trait (如 String、Vec 类型亦是智能指针)
    d. 确定性析构
        RAII : Resource Acquisition Is Initialization 获取资源即初始化( RAII 概念
        源于 C++ [ RAII 机制是使用构造函数来源初始化资源，使用析构函数来回收资源])。
        RAII 别名：作用域界定资源管理( Scope-Bound Resource Management, SBRM)
    e. 使用 Valgrind 来检测内存泄漏：先使用 rustc 编译后 使用 valgrind 检测如
       先执行" rustc box.rs "命令再执行" valgrind ./box "命令
    f. drop-flag: 标记函数调用栈离开作用域时是否调用析构函数。对于结构体或枚举体这种
       复合类型而言并不存在隐式的 drop-flag。只有在函数调用时这些复合结构实例被初始化
       之后编译器才会加上 drop-flag。若复合结构本身实现了 Drop 则会先调用其本身的析构
       函数，然后再调用其成员的析构函数；否则会直接调用其成员的析构函数。
       // 注：对于实现 Copy 的类型是没有析构函数的，因为实现了 Copy 的类型会复制，其
              生命周期不受析构函数的影响，所以也就没必要存在析构函数

4.2.3 内在泄漏(Memory Leak)与内存安全(Memory Safety)：(p110~p115)
    a. RAII 的设计目标即是替代 GC，防止内存泄漏。然 RAII　并非"银弹"。若使用不当亦会
       造成内存泄漏
    b. Rc<T> 即引用计数(reference counting)智能指针：可用于共享同一块堆内存但其包含
       数据 T 是不可变的
    c. 内存安全的含义："内存泄漏"并不在"内存安全"概念范围内
       Rust 中使用 Option 枚举体代替空指针(保证内存安全)、悬垂指针(dangling pointer)。
       Rust 编译器在编译期可检测数组越界的问题，避免缓冲区溢出
    d. 内存泄愤原因
           线程崩溃，析构函数无法调用
           使用引用计数时造成了循环引用
           调用 Rust 标准库中的 forget 函数主动泄漏

4.2.4 复合类型的内存分配和布局(p115~p117[*])
    a. 基本原生数据类型，Rust 默认将其分配到栈中

*/
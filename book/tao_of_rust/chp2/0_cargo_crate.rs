/*
            chp2 语言精要

2.1.2 编译器
    Rust 是一门静态编译型语言。 Rust 官方的编译器叫 rustc，负责将 Rust 源代码编译为可执行文件或其它
    库文件(.a、.so、.lib、.dll 等)

2.1.3 核心库
    Rust 语言的语法由核心库和标准库共同提供，其中 Rust 核心库是标准库的基础，核心库中定义的是 Rust
    语言的核心，不依赖于操作系统和网络等相关的库，甚至不知道堆分配，也不提供并发和 I/O。
    可以通过在模块顶部引入 #![no_std] 来使用核心库，核心库包括如下部分：
        基础的 trait，如 Copy、Debug、Display、Option 等。
        基本原始类型，如 bool、char、i8/u8、i16/u16、i32/u32、i64/u64、isize/usize、f32/f64、str、
                        array、slice、tuple、pointer 等。
        一些内建宏，如 assert!、cfg!、env!、file!、write!、panic! 等
    // 做嵌入式开发的时候，核心库是必需的。

2.1.4 标准库       // instrinsic [ɪnˈtrɪnsɪk]adj.本质(的)
    Rust 标准库提供应用程序开发所需要的基础和跨平台支持。标准库包含的内容大概如下：
       (1). 一些基本 trait、原始数据类型、功能型数据类型和常用宏等。由于这些是重导出(re-export)的
            核心库的部分，所以会有一些与核心库几乎完全一致的 API。
       (2). 并发、I/O和运行时。例如线程模块、用于消息传递的通道类型、Sync trait 等并发模块，文件、
            TCP、UDP、管道、套接字等常见 I/O。
       (3). 平台抽象。OS 模块提供了许多与操作系统交互的基本功能，包括程序参数、环境变量和目录导航；
            路径模块封装了处理文件路径的平台特定规则。
       (4). 底层操作接口，如 std::mem、std::ptr、std::intrinsics 等，操作内存、指针、调用编译器
            固有参数。
       (5). 可选和错误处理类型 Option 和 Result，以及各种迭代器等。
    Interview : 核心库与标准库的区别

2.1.5 包管理器
    a. Rust 提供了非常方便的包管理器 Cargo。 Cargo 不局限于包管理其还为 Rust 生态系统提供了标准
       工作流。Cargo 能够管理整个工作流程，从创建项目、运行单元测试和基准测试、构建发布链接库再到
       到运行可执行文件等。Cargo 为开发者提供了极大的方便。
    b. 在安装好 Rust 环境后可直接使用 cargo new 命令默认创建一个用于编写可执行二进制文件的项目。
       通过给 cargo new 命令添加 --lib 参数，则可以创建用于编写库的项目。此外通过 cargo build、
       cargo check 及 cargo run 命令可分别对项目进行编译、检查及运行。

2.2 语句与表达式 (代码示例参阅" p13 ~ p14 ")
    a. Rust 的语法可以分为两大类：语句(Statement)和表达式(Expression)。语句是指要执行的一些操作
       和产生副作用的表达式。表达式主要用于计算求值。
    b. 语句又分为两种：声明语句(Declaration statement)和表达式语句(Expression statement)。
       (1). 声明语句，用于声明各种语言项(Item),包括声明变量、静态变量、常量、结构体、函数等，以及
            通过 extern 和 use 关键字引用包及模块等。
       (2). 表达式语句，特指以分号结尾的表达式。此类表达式求值结果将会被舍弃，并总是返回单元类型()
    c. Rust 编译器解析代码时若遇上语句则执行，若遇上表达式则会对表达式求值。声明非空 tuple 返回值
       的函数即"块表达式"(总是返回块中最后一个表达式的值)。若函数体以分号结尾则为" 块表达式语句 "(
       返回空 tuple 即" () ")

(零散知识点)语句和表达式(表达式总是返回值)：
    a. 块表达式(block expression):块表达式就是用花括号{}括起来的一组表达式的集合，表达式间一般以分号
       分隔。块表达式的值，就是最后一个表达式的值。如" let x:i32 = { println!("Hello."); 5 };＂;若
       以"语句"结尾则块表达式的值为单元类型即空 tuple "()"如" let x:() = { println!("Hello."); }; "
    b. 表达式语句：由一个表达式和一个分号组成，即在表达式后面加一个分号就将一个表达式转变为了一个语句。
       所以有多少种表达式就有多少种表达式语句。
    c. 表达式总是会返回值(表达一个结果)，表达式是不以分号结尾且有值的代码("block"可有返回值故 block
       可为表达式)
    d. 除两种语句("声明语句、表达式语句")外其余皆为表达式

2.3 变量与绑定
    通过 let 创建变量一般称为"绑定(Binding)"：表明标识符(Identifier)和值(Value)之间建立的关联关系

2.3.1 位置表达式与值表达式(参阅" p15 ")
      a. Rust 中的表达式一般可分为位置表达式(Place Expression)及值表达式(Value Expression)。其它
         语言中一般称作"左值(LValue)和右值(RValue)"
      b. 值表达式不能出现于位置上下文中

2.3.2 不可变绑定与可变绑定
    a. 使用 let 关键字声明的位置表达式默认不可变，为不可变绑定。对不可变绑定变量赋值则编译器报错。
    b. 通过 mut 关键字可声明可变的位置表达式，即是可变绑定。其可正常读写
    c. 从语义上而言 let 默认的不可变绑定只能对相应的存储单元进行读取，而 let mut 声明的可变绑定则
       可对相应的存储单元进行写入
    d. 获取可变引用必须先声明可变绑定

2.3.3 所有权与借用 （参阅" p16 ~ p17 "）
    a. 当位置表达式出现在值上下文中时，该位置表达式将会把内存地址转移给另一个位置表达式，这其实是
       所有权的转移。
    b. 在语义上，每个变量绑定实际上都拥有该存储单元的所有权，这种转移内存地址的行为就是所有权转移，
       在 Rust 中称为移动(Move)语义，那种不转移的情况实际上是一种复制(Copy)语义。Rust 没有 GC 故
       完全依靠所有权来进行内存管理
    c. 日常开发中有时无需转移所有权。Rust 提供借用(Borrow)操作符(&)，可以直接获取表达式的存储单元
       地址即内存地址，可通过该内存位置对存储进行读取。
    d. 从语义上而言无论是 &a 还是 &mut c 都相当于 a 和 c 所有权的"租借"，而 a 和 c 依旧保留它们
       的所有权。故将"&"称为借用操作符。通过借用操作符获取的类型即引用(Reference)类型，故 &a 和
       &mut c 皆为引用类型

2.4 作用域和生命周期
    // lexic ['leksik]adj.词汇的[等价于" lexical "] // lexical [ˈleksɪkl]adj.词汇/词法(的)
    a. Rust 语言作用域是静态作用域即词法作用域(Lexical Scope)。由一对花括号来开辟作用域，其作用域
       在词法分析阶段就已经确定了，不会动态改变。
    b. 连续使用 let 定义同名变量的做法叫变量遮蔽(Variable Shadow)，最终变量值由最后一个变量定义
       确定(因变量 variable 通过 let 重新绑定)。块空间(花括号开辟的作用域)实际上是一段词法作用域
    c. 在词法作用域内部使用花括号"{}"开辟新的词法作用域后，两个作用域相互独立，在不同词法作用域内
       声明的变量绑定拥有不同的生命周期(LifeTime)。尽管如此变量绑定的生命周期总是遵循这样的规律：
       从使用 let 创建变量绑定时开始，到超出词法作用域范围时结束

2.4.3 函数指针
    a. 函数签名类型在 Rust 中是函数指针(Fn-pointer Type)类型
    b. 函数可作为参数及作为返回值(参阅" p19 ~ p20 "：注意区分"函数类型与函数指针类型")

2.4.4 CTFE 机制
    (类似 C++ 或 D 语言) Rust 编译器亦拥有编译时函数执行(Compile-Time Function Execution,CTFE)
    的能力。如下示例
    Interview : const 关键字可用于修饰函数 fn (区别于其它语言)

*/
// 使用 const fn 定义函数 init_len : 返回固定值 5
const fn init_len() -> usize {
    return 5;
}
fn main() {
    /* 通过"[0;N]"形式来初始化初始值为"0"、长度为"N"的数组：
      a. "Rust"中固定长度数组须在编译期知道长度否则编译报错，故 init_len 函数必须在编译期求值(这
         就是" CTFE "能力)。使用 const fn 定义的函数必须可以确定值，不能存在歧义。与 fn 定义函数
         区别于" const fn "可以强制编译器在编译期执行函数。其中关键字 const 一般用于定义全局常量
      b. 除" const fn "外官方亦实现" const generics "特性。支持" const generics "特性，将可以
         实现类似" impl<T,const N:usize> Foo for [T:N] {...} "的代码，可以为所有长度的数组实现
         " trait Foo "。那么使用数组的体验将会得到很大的提升
      c. Rust 中的 CTFE 是由 miri 来执行，miri 是一个 MIR 解释器:已被集成到 rustc 编译器。Rust
         编译器目前可支持的常量表达式有：" 字面量、元组、数组、字段结构体、枚举、仅包含单行代码的
         表达式、范围 "等(但 Rust 欲拥有完善的 CTFE 支持还有很多工作要做)
    */
    let arr = [0;init_len()];
    println!("{:?}", arr);
}

/*
2.4.5 闭包(参阅" p21 ~ p22 ")
    a. 闭包特点：
        (1). 可以像匿名函数一样被调用
        (2). 可以捕获上下文环境中的自由变量
        (3). 可以自动推导输入和返回的类型
    b. 对比 Go 语言中的匿名函数：
                // 声明
                fn := func(a,b int) int {
                    return a+b
                }
                // 调用匿名函数
                fn(1,2);
        Rust 无类似 Golang 中匿名函数的用法如:
                let func = fn ()->i32{   // 飘红报错
                    3
                }
        解决方案：闭包(相比 Golang 匿名函数更加简化和先进[仅保留必须部分如参数及返回值])其用法如：
             // let func = |a:i32,b:i32|->i32{ a+b };
             // 简化写法 : 自动推导输入和返回的类型
             let func = |a,b| a+b ;
    c. Rust 中闭包与函数有一个重要的区别就是闭包可以捕获外部变量而函数不可以。Rust 中的闭包实际上
       就是由一个匿名结构体和 trait 来组合实现的。
       Interview : Rust函数内不可捕获外部自由变量(非常量)且可在函数内部定义非匿名函数(区别其它语言)

" Golang、Rust "(匿名)函数及闭包：
    a. Golang 函数中不可再定义非匿名函数(而 Rust 可以)
       (1) Golang 函数中定义的匿名函数可获取环境中的"局部或全局变量/常量"
    b. Rust 函数中可以定义非匿名(即非闭包)函数:
       (1). 其可捕获环境中的常量(即 const 绑定的常量)但不可捕获环境中的自由变量(即 let 绑定的变量)
       (2). Rust 闭包 : 类比 Golang 匿名函数但功能更强大(如可自动推导输入及返回的类型)
    c. Golang 闭包(面向函数)则是用于" 绑定环境因素 "(可用结构体替代实现[面向对象])：与" Rust 闭包
       "非同一含义。故 Golang 中的"匿名函数"与 Rust 中的"闭包"有着类似的语义。

问题：
    Rust 中如何定义全局变量 ?

*/
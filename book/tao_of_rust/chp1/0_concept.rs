
/*
            chp1 : 新时代的语言

1.2. Rust 遵循三条设计哲学:([自]安全、抽象、实用)
    内存安全
    零成本抽象
    实用性(如"异常处理")
    语言一致性
    // 注：Rust 所有语法特性皆围绕这三条哲学而设计(亦是 Rust 一致性的基础)

1.2.1 内存安全
    a. Rust 语言如果想保证内存安全，首先要做的就是保证类型安全
    b. 类型系统 及 内存管理模型 作用(参阅" p3 ~ p4 ")
    Interview ：请举例说明内存不完全(即出现内存访问错误)的几种情况、产生原因(访问未定义内存)及
                Rust 如何解决(借助"内存管理模型"[即所有权系统、借用和生命周期])

1.2.2 零成本抽象
    Rust 中零成本抽象的基石就是 泛型 和 trait

1.2.3 实用性
    a. 实践性：(参阅" p5 ~ p6 ")
        (1) 为了保证程序的健壮性，Rust重新审视了错误处理机制。日常开发中一般有三类非正常情况：
            失败、错误和异常(比对"C、C++、Java")...
        (2) Rust 针对这三类非正常情况分别提供了专门的处理方式，让开发者可以分情况去选择(细粒度)
            (a). 对于失败的情况，可以使用断言工具
            (b). 对于错误，Rust 提供了基于返回值的分层错误处理方式，比如 Option<T> 可以用来处理
                 可能存在空值的情况，而 Result<T> 就专门用来处理可以被合理解决并需要传播的错误
            Interview : Option<T> 及 Result<T> 所适用的处理错误场景
            (c). 对于异常，Rust 将其看作无法被合理解决的问题，提供线 panic! 机制，在发生异常的
                 时候，线程可以安全地退出
            // 通过这样精心的设计，开发者就可以从更细的粒度上对非正常情况进行合理处理，最终编写出
               更加健壮的系统
        Interview ：Rust 针对非正常情况提供的三种专门处理方式
        (3) 为了和现有的生态系统良好地集成，Rust支持非常方便且零成本的 FFI (即外部函数接口[Foreign
            Function Interface，FFI])机制，兼容 C-ABI，并且从语言层面分成 Safe Rust 和 Unsafe
            Rust 两部分。其中 Unsafe Rust 专门和外部系统打交道，比如操作系统内核。之所以这样划分，
            是因为 Rust 编译器的检查和跟踪是有能力范围的，它不可能检查到外部其它语言接口的安全状态，
            所以只能靠开发者自己来保证安全 ...
         Interview : " Safe "及" Unsafe "适用场景
        (4) 为了让开发者更方便相互协作，Rust 提供了非常好用的包管理器 Cargo。Rust 代码是以包(crate)
            为编译和分发单位的，Cargo 提供了很多命令，方便开发者创建、构建、分发、管理自己的包。Cargo
            也提供插件机制，方便开发者编写自定义的插件，来满足更多的需求...
        (5) 从以下几点出发来学习 Rust:
            (a). 保持初学者心态。当面对 Rust 中难以理解的概念时，先不要急于将其它语言的经验套用其上，
                 而应该从 Rust 的设计哲学出发，去理解如此设计 Rust 的语言的特性的原因，寻找其内在的
                 一致性(注：Rust 的设计哲学[安全、抽象、实用])
            (b). 先学习概念再动手实践。
            (c). 把编译器当作朋友。不要忽略 Rust 编译器的诊断信息，大多数情况下，这些诊断信息已经把
                 错误原因阐述得非常明确。这些诊断信息可以帮助你学习 Rust，纠正自己的错误认知
             // 俗话说得好，逆境也是机遇
    b. 有效性和稳定性
        Rust 语言解决了内存安全和并发安全的问题，可以极大地提升软件的质量。

1.3.1 语言架构(参阅" p8 ~ p9 ")
    a. 将 Rust 语言概念分成了 4 层。
       (1). 最底层是安全内存管理层，该层主要是涉及内在管理相关的概念。
       (2). 倒数第二层是类型系统层，该层起到承上启下的作用。类型系统层承载了上层的所有权系统语义和
            混合编程范式，赋予了 Rust 语言高级抽象表达能力和安全性。同时，还保留了对底层代码的执行、
            数据表示和内存分配等操作的控制能力。
       (3). 对于开发者而言，只需要掌握类型系统、所有权系统和混合式编程范式即可，不需要操心底层的内存
            是否安全，因为有编译器和类型系统帮忙处理。在这个语言架构之下，人和编译器共用同一套"心智
            模型"，这样可以极大地保证系统的安全和健壮性
       // 在后续章节中，会依照该语言架构对 Rust 语言自底而上进行分层探索，以帮助读者对 Rust 语言的
          概念融会贯通。

附加： // nightly[ˈnaɪtli]adj/adv.夜间(的)
    a. WebAssembly(wasm)
        // assemble[əˈsembl]v.集合,装配     // assembly[əˈsembli]n.集合(汇编),装配
        WebAssembly 设计初衷用于媲美 JavaScript
                    其可直接用于浏览器解析且其体积更小执行更快(二进制形式表示)
     b. CLI : Command Line Interface : 命令行界面
     c. RFC : Request For Comments : 请求评论(编排文件[一系列以编号排定的文件])
               (一系列以编号排定的文件[基本的互联网通信协议都有在RFC文件内详细说明])
     c. Rust 团队维护三个发行分支：稳定版(Stable)、测试版(Beta)和开发版(Nightly)
     d. LLVM ：Low Level Virtual Machine 底层虚拟机
               ( LLVM 是构架编译器[compiler]的框架系统[由 C++ 编写])
               LLVM IR 简介：LLVM 有自己的一套中间表示 IR(Intermedia Representation)。IR
                            在编译器中承担着一个承前启后的角色。编译器前端对源程序进行语法
                            和语义分析生成 IR。编译器后端则将 IR 汇编成对应的机器指令,此外
                            编译器中大部分优化都在 IR 上完成
                            IR 缩写可能之意：Instruction Registe 指令寄存器
     e. AST : Abstract Syntax Tree 抽象语法树
     f. 生命周期参数：主用于避免"悬垂指针"
     g. Wild pointers
            Resource Allocation Is Initialization (RALL)    // 获取资源即初始化
            No safe pointer dereferencing
     h. PL : Programme Language

    Interview : 野指针与悬垂指针

*/

/*
类型系统
    计算机以二进制形式存储信息，故无论何种数据对计算机而言皆为字节序列(即" 0 和 1 "的排列)，若使用
    " 0 和 1 "来存储、表示及处理各种信息则必然会产生过大的心智负担故类型应运而生。

3.1 通用概念
    a. 所谓类型即是对数据进行细粒度的区分(如整数、小数、文本等(更细粒度为布尔值、有无符号整形、单双
       精度浮点数、字符与字符串及自定义类型等)
    b. 不同类型占用的内存不同，与直接操作比特位相比，直接操作类型可更安全、更有效利用内存如创建一个
        u32 类型则 Rust 会自动分配 4 个字节来存储该值
    c. 类型系统是编程语言的基础和核心：因编程语言目的即是存储和处理信息。故不同编程语言间的区别即是
       " 如何存储和处理信息 "

3.1.1 类型系统的作用(参阅" p52 ")
    a. 排查错误
    b. 抽象
    c. 文档([自]即可读性)
    d. 优化效率
    e. 类型安全
       类型安全的语言可以避免类型间的无效计算、保证内存安全及避免主义上的逻辑错误

3.1.2 类型系统分类
    在编译期进行类型检查的语言属于静态类型;在运行期进行类型检查的语言属于动态类型。静态类型语言能在
    编译期对代码进行静态分析依靠的即是"类型系统"。强大的类型系统可对类型进行自动推导，因此一些静态
    语言编写代码时无需显式指定具体类型(如 Haskell 就被称为"隐式静态类型")。 Rust 受 Haskell 启发
    亦可自动推导但不如 Haskell 强大，在 Rust 中有些地方还需显式指定类型故 Rust 属于显式静态类型。

3.1.3 类型系统与多态性(参阅" p53 ")   // ad-hoc[ˌæd'hɒk]adj&n.特别(的),特定
    a. 若一个类型系统允许一段代码在不同的上下文中具有不同类型则该类型系统即是多态类型系统。于静态
       类型语言来说"多态"的优势即可在不影响类型丰富的前提下为不同类型编写"通用的代码"
    b. 现代编程语言包含三种多态形式：
            (1). 参数化多态(Parametric polymorphism)
            (2). Ad-hoc多态(Ad-hoc polymorphism)
            (3). 子类型多态(Subtype polymorphism)
       若按多态发生的时间划分又可分为：
            (1). 静多态(Static Polymorphism)
            (2). 动多态(Dynamic Polymorphism)
        // 静多态发生在编译期，动多态发生在运行时。参数化多态及 Ad-hoc 多态(特定多态)一般为静多态
           而子类型多态一般是动多态。静多态牺牲灵活性换取性能而动多态牺牲性能换取灵活性。动多态在
           运行时需要查表，占用较多空间故一般情况下都使用静多态。
        // Rust 同时支持静多态和动多态(静多态就是一种零成本抽象)
   c. 参数化多态实际就是指泛型。很多时候函数或数据类型都需要适应于多种类型以避免大量的重复性工作。
      泛型使得语言极具表达力同时亦能保证静态类型安全
   d. " Ad-hoc "多态亦称特定多态。" Ad-hoc "源于拉丁语系用于表示一种特定情况。" Ad-hoc "多态是指
      同一种行为定义在不同上下文中响应不同的行为表现。Haskell 语言中使用 Typeclass 来支持 Ad-hoc
      多态，(受 Haskell 启发) Rust 语言使用 trait 来支持" Ad-hoc "多态(故 Rust 的 trait 系统的
      概念类比 Haskell 中的 Typeclass )
   e. 子类型多态用于有"继承"概念的面向对象语言中，尤其是 Java 语言(其类型多态即是子类型多态)。而
      Rust 语言并无类似 Java 中的继承概念故"不存在子类型多态"(严格来说 Rust 有另一种仅存在于生命
      周期中的子类型多态[参阅 13 章])。所以" Rust 类型系统目前仅支持 参数化多态 及 Ad-hoc 多态"
      也就是" 泛型和 trait "

3.2 Rust 类型系统概述
    Rust 是一门强类型且类型安全的静态语言。 Rust 中一切皆表达式、表达式皆有值、值皆有类型故 Rust
    中一切皆类型。其类型系统大致如下：
        a. 基本类型和复合类型
        b. 作用域：Rust 把作用域亦纳入类型系统(生命周期标记)
        c. 有无(正确)返回值类型：一些表达式有时没有返回值(即仅返回单元值或空 tuple ["()"])有时有
           返回值，或者有时返回正确值有时返回错误值，Rust 亦将这类情况也纳入类型系统，也就是诸如
           Option<T> 和 Result<T,E> 的可选类型，从而强制开发者须分别处理此两种情形。
        d. 无法返回值类型：一些根本无法返回值的情况(即 never 类型)如线程崩溃、break 或 continue
           等行为也都被纳入类型系统
        // 可以说 Rust 类型系统基本囊括了编程中会遇到的各种类型故" Rust 是类型安全的语言 "

3.2.1 类型大小
    不同类型本质上是"内存占用空间和编码方式的"不同。Rust 中没有 GC (garbage collection),其内存
    首先由编译器来分配，Rust 代码被编译为 LLVM IR (携带内存分配信息)。故编译器需要事先知道类型的
    大小才能合理分配内存。
    a. 可确定大小类型和动态大小类型(参阅" p54 "):  // DST ： 动态大小类型
        (0).  Rust 中绝大部分类型都是在"编译期可确定大小的类型(Sized Type)"如原生整数类型 u32 固定
             是 4 个字节、u64 是 8 个字节等等皆是可在编译期确定大小的类型。然而 Rust 中亦有少量动态
             大小的类型( Dynamic Sized Type，DST ),如 str 类型的字符串字面量，编译器不可能事先知道
             程序中会出现什么样的字符串，故对于编译器而言 str 类型的大小是无法确定的。针对于这种情况
              Rust 提供了引用类型(因引用总有固定"且在编译期已知的"大小)
        (1). 字符串切片 &str 就是一种引用类型,其存储于栈上由" 指针和长度 "信息组成而 str 字符串序列
             存储于程序的静态只读数据段或者堆内存中(参阅第 4 章)。" &str "中指针存储 str 字符串序列
             的起始地址(占用内存固定大小),其长度亦是占用内存固定大小的整数。这样一来 &str 即是可确定
             大小的类型，编译器可正确为其分配内存空间，str 也会在运行时于堆上开辟内存空间。
                 ------------------------------------------
                    栈    &str     *         5
                                   ^         ^
                                   |         |
                                  指针      长度
                 ------------------------------------------
                                   | 指
                                   v 向
                    堆    str     h e l l o
                 -------------------------------------------
                 // (同理) Rust 中的数组 [T] 亦是动态大小类型，编译器无法确定其占用内存大小
        (2). 胖指针(Fat Pointer): 包含动态大小类型地址信息和携带长度信息的指针。&str 即是胖指针
                 println!("{}",std::mem::size_of::<&[u32;5]>()); // Console:" 8 "
                 println!("{}",std::mem::size_of::<&[u32]>()); // Console:" 16 "
                 // 输出结果分别为" 8、16 "即"&[u32;5]"类型为普通指针而"&[u32]"类型为胖指针
                 // [自]" std::mem::size_of::<&RefType>() ":返回引用类型字节数
        (3). 零散知识点：
                数组作为函数形参：若数组元素类型是可复制的类型即实现 Copy trait (如 u32 )则整个
                数组亦是可复制的，那么在函数内部操作拷备份的数组对原数组无影响。欲操作原数组可将
                形参改为"借用"
    b. 零大小类型     // ZST：Zero Sized Type 零大小类型
        如单元类型和单元结构体，大小皆为零
        (0). 零散知识点：
              单元类型和单元结构体大小为零，由单元类型组成的数组大小亦是零。
              零大小类型 ZST 特点 : 值即是其本身，运行时并不占用内存空间(代表的意义正是" 空 ")。
        (1). 单元示例(如" vec![();10] "即是使用单元类型制造长度为 10 的向量)
              "Vec<()>"类型可用于只需迭代次数的场合来获取较高性能(因 Vec 内部迭代器会针对 ZST 进行
              优化)。标准库"HashSet<T>、BTreeSet<T>"即"HashMap<K,()>、BTreeMap<K,()>"，如此设计
              为可共用"HashMap<K,V>、BTreeMap<K,V>"而无需再重新实现一遍"HashSet<T>、BTreeSet<T>"
        Interview :  "Vec<()>"类型的适用场景
    c. 底类型  // bang[bæŋ]v&n.重击,感叹号      // diverge[daɪˈvɜːdʒ]v.发散
        底类型(Bottom Type)是源自类型理论的术语即 never 类型其特点"没有值、是其它任意类型的子类型"。
        如果说零大小类型 ZST 表示" 空 "的话则底类型表示" 无 "(底类型无值且可等价于任意类型)。Rust 中
        底类型用叹号(!)表示(亦称称作"Bang Type")。Rust 中有多种情况确实没有值，但为了类型安全必须将
        没有值的多种情况纳入类型系统进行统一管理。纳入类型管理的多种情况如下：
        (0). 发散函数(Diverging Function)
             发散函数是指会导致线程崩溃的 panic!("This function never returns!")，或者用于退出函数
             的" std::process::exit "，这类函数永远都不会有返回值
        (1). continue 和 break 关键字
             continue、break 仅表示流程跳转并无返回值
        (2). loop 循环
             loop 虽可返回值但也有需要无限循环的时候
        (3). 空枚举 : 如" enum Void{} "
             Rust 中使用 Result 类型来处理错误，强制开发者处理 Ok 和 Err 两种情况。但有时可能永远
             没有 Err 则用空枚举" enum Void{} "(亦可使用"if let")避免处理 Err 情况(待新版本实现)
        Interview : 空枚举 与 空结构体 的区别与应用场景

3.2.2 类型推导          // hashkell[ˈhæskəl]n.哈斯克尔
    a. 类型标注在 Rust 中属于语法的一部分。Rust 属于显式类型语言，其功能虽非 Hashkell 强大但亦能在
       局部范围内支持类型推导。示例如下：
            // sum 函数声明
            fn sum(a: u32, b: i64) -> u32 {
                a + (b as u32)
            }
            // sub 函数声明
            fn sub(a: u8, b: i16) -> i16 {
                a as i16 - b
            }
            fn main() {
                // 调用函数前变量自动推导为数值默认类型" i32 "(即"a,b"皆默认自动推导为 i32 类型)
                let a = 1;
                let b = 2;
                // 首次调用函数则实参默认自动推导并绑定为形参声明(须兼容)的类型
                assert_eq!(sum(a, b), 3);
                // 再次调用若类型不兼容则报错(因相应变量类型在首次调用时已被成功推断并绑定)
                // assert_eq!(sub(a, b), 3);

                // 创建空向量即" Vec<_> "(" _ "为通配符)
                // let mut vec:Vec<_> = Vec::new();
                let mut vec = Vec::new();
                let elem = 5u8;
                // 同理首次调用自动推导 vec 类型
                vec.push(elem);
                assert_eq!(vec, [5]);
            }
    b. Turbofish 操作符("标注类型")：" ::<Type> "       // turbofish['tɜːbəfɪʃ]
       当 Rust 无法从上下文中自动推导出类型时，编译器会通过错误信息提示"请求添加类型标注"如:
          // Rust 无法根据上下文自动推导而需要进行"类型标注"的情况
          fn main() {
              let x = "1";
              /* 编译错误:
                  error[E0284]: type annotations required: cannot resolve
                                     `<_ as std::str::FromStr>::Err == _`
                     println!("{:?}",x.parse().unwrap());
                                       ^^^^^
                 // 调用"parse"方法原意是想把字符串"1"转换为整数类型 1，但 parse 是一个泛型方法其
                    无法自动推导类型故 Rust 无法确定转换为哪种类型(u32、i32 还是 f32 类型)的整数。
                      parse源码：  pub fn parse<F: FromStr>(&self) -> Result<F, F::Err> {
                                      FromStr::from_str(self)
                                   }
                 // 解决方案：明确指定"类型标注"(即显示标注类型[可在"位置或值"表达式中标注])
              */
              //println!("{:?}",x.parse().unwrap());

              // 类型标注方式 1：位置表达式
              let int_x:i32 = x.parse().unwrap();
              assert_eq!(int_x,1);
              /* 类型标注方式 2：值表达式(推荐使用) // " ::<> "形式的标注类型即 turbofish 操作符
                 使用" parse::<i32>() "形式为泛型函数标注类型(避免" 位置表达式中标注类型 "的变量
                 声明[尤其在无需声明太多变量时]且代码结构显示更加紧凑)。
              */
              println!("{:?}",x.parse::<i32>().unwrap()); // Console:" 1 "
          }
    c. 类型推导的不足
       目前 Rust 类型推导还存在缺陷(尚需完善)

*/
fn main() {
    let a = 0;
    /* 编译错误：
         error[E0599]: no method named `is_positive` found for type `{integer}`
                                                          in the current scope
             let a_pos = a.is_positive();
                           ^^^^^^^^^^^
        // " is_positive "原意是"整数类型实现的用于判断正负"的方法。错误信息中出现
           的" {integer} "并非真实类型，其仅被用于错误信息中但已足够表明编译器已知
           变量 a 是整数类型(但并未推导出具体类型[因没有足够的上下文信息辅助编译器
           进行推导]故 Rust 编程时按需显示声明类型方为正道)
    */
    let a_pos = a.is_positive();
}

/*
0. 解引用
   " 解引用(Deref) "与" 取引用(Ref) "互为反操作。取引用有 &、&mut 等操作符
   而解引用有" * "操作符

16.1 自定义解引用(p169[?])
    解引用操作可被自定义即实现标准库" std::ops::Deref/DerefMut "trait

16.2 自动解引用
    自动 deref 的规则是"若类型 T 可解引用为 U 即 T：Deref<U>"则 &T 可转化为 &U

16.3 自动解引用的用处(p171[*])
     " &* "两个操作符连写 与 分开写 是不同褒义

16.4 有时候需要手动处理
    若智能指针中的方法与其内部方法冲突，则编译器会优先调用当前最匹配的类型而不会
    执行自动 deref,此种情况下只能按需手动 deref 来实现

16.5 智能指针

16.5.1 引用计数
    a. Rust 提供的引用计数指针有" std::rc::Rc<T> "类型及" std::sync::Arc<T> "类型
    b. Rc 类型和 Arc 类型的主要区别是：Rc 类型的引用计数是普通整数操作，仅用于单线程；
       而 Arc 类型的引用计数是原子操作，可用于多线程

16.5.2 Cow
    在 Rust 语境中，因 Copy 和 Clone 有比较明确的语义区分，一般把 Cow 解释为" Clone
    -On-Write "(写时复制)，其对指向的数据可能" 拥有或不拥有所有权 "

*/

/*
0. 语句和表达式

3.1 语句(Statement)
    a. 表达式总会产生值故其必然有类型，语句不产生值故其类型默认认为"()"
    b. 表达式后追加分号即是语句；语句置于语句块中包起来即可看作是表达式

3.2 表达式(Expression)
    a. Rust 中的表达式语法具有非常好的"一致性"，每种表达式都可以嵌入到另一种
       表达式中，组成更强大的表达式
    b. Rust 中表达式
        (0). 字面量表达式
        (1). 方法调用表达式
        (2). "数组/索引"表达式
        (3). 运算符(单目/双目)表达式
    c. Rust 表达式又可分为左值(lvalue)和右值(rvalue)
       其中左值可表达内存地址故可置于运算符左侧，其余皆为右值

3.2.1 运算表达式
    a. 运算符: " << "左移、" >> "右移
    b. 按位取反 及 逻辑取反 皆为" ! "(被操作数为 bool 类型则为逻辑取反[其余
       类型则为按位取反])

3.2.2 赋值表达式(p37[*])
    a. 一个左值表达式、赋值运算符("=")和右值表达式可构成一个"赋值表达式"。如
            let mut x : i32 = 1;
            x = 2;
        // "x = 2"是一个赋值表达式，它末尾加上分号才能组成一个语句。赋值表达式
            具有"副作用"：当它执行的时候会把右边表达式的值"复制或移动(copy or
            move)"到左边的表达式中
    b. Rust 规定整个赋值表达式的类型为" unit 即空 tuple ()" 如:
          let (x, mut y) = (1, 2);
          let z = (y = x); // 整个赋值表达式" y=x "对应的类型和值为空 tuple ()
          println!("{:?}", z);    // Console:" () "
       // 设计初衷：比如防止连续赋值，若有" x:i32, y:i32, z:i32 "则" x = y = z "
          会发生编译错误(因变量 z 类型为 i32 但却用" () "对其初始化，编译器不允许)
       // C语言允许连续赋值：此设计并未带来任何性能的提升且代码结构不够清晰
    c.因赋值表达式类型为" () "故其无法用于 if 条件表达式中
    d. Rust 不支持 ++、-- 运算符：请使用" +=1 "、" -=1 "代替

3.2.3 语句块表达式
    在 Rust 中语句块也可以是表达式的一部分。语句和表达式的区分方式是代码体末是否带
    分号(;)。若携带了分号则为语句即类型是" () "；若未携带分号其最后一个表达式的类型
    即是语句块表达式的类型。如
    let x : () = { println!("Hello."); };     // 代码体末已携带分号故其返回" () "
    let x : i32 = { println!("Hello."); 5 };
              // 代码体末未携带分号故其返回的类型即是代码体最后一个表达式返回的类型
    let x : () = {};     // 空代码体亦返回" () "
        // [自]"{}"返回值等价于"{ //... ; }"返回值：因其返回值皆相当于代码体末最后
               表达式[即"空表达式"]的返回值)

3.3 if-else(p39[*])
    a. 在 if 语句中后续的结果语句块要求必须使用花括号"{}"包起来(设计初衷：增强可读
       性)，相反"条件表达式"并未强制要求使用小括号包起来(若加上小括号编译器反而认为
       是多余的从而给出警告)
    b. if-else 亦可当表达式使用如
          let x : i32 = if condition{ 1 } else { 10 };
        // 故没有必要设计三元表达式且笔者认为这样的语法一致性、扩展性及可读性更好
    c. if-else 分支类型必须一致否则编译错误，[自]可以理解为若 else 分支为" {} "则
       可省略反之若未显示 else 分支则其默认为" else{} "(其返回空 tuple 即"()")如：
            fn main(){
                if 3 == 3 {
                    6
                }    // [自]注：此处是否有分号(;)决定于是否根据函数返回值进行判断
            }
            // 编译报错：
            error[E0308]: mismatched types
              fn main() {
                        - expected `()` because of default return type
                      6
                      ^ expected `()`, found integer
            // [自]分析：因" main() "函数返回" () "。一般普通类型以 if 分支内返回值
               的类型为基准来判断 else 分支内返回类型(但编译器会根据整个函数的返回值
               类型进行优先判断)
   d. 编译器会根据整个函数的返回值类型进行优先判断
        fn main() -> i32 {
            // 飘红报错：mismatched types [E0308] expected `i32`, found `()`
            if 3 == 3 {
                6
            }   // [自]注：此处是否有分号(;)决定于是否根据函数返回值进行判断(有分号
                //        为语句故仅根据 if-else 原则判断;没有分号则根据返回值类型
                //        进行判断[故编译器提示信息:有无分号不尽一致])
        }

3.3.1 loop
    a. 循环控制
           // A counter variable
           let (mut m, n) = (1, 1);
           // 可在"loop、while、for"循环前添加"生命周期标识符"(类比 Go 语言的 flag )
           'a: loop {
               if m < 100 {
                    m += 1
               } else {
                   'b: loop {
                         if m + n > 50 {
                             println!("break");
                             // 内部循环可使用 break 语句选择跳出层级
                             break 'a;
                         } else {
                             continue 'a;
                         }
                   }
               }
    b. loop 结构亦可作为表达式的一部分(类比" if 结构")
          let v = loop {
            break 10  // 此处分号可有可无([自]因break会携带表达式的值跳出[类比return])
          };
          println!("{}",v);
          // 在 loop 内部 break 后可跟一个表达式，此表达式就是最终 loop 表达式的值
    c. 若 loop 永不返回则其类型为"发散类型"(编译器能检测出其类型)
          // 编译器可判断出 v 的类型为"发散类型"(其后语句永远无法执行)
          let v = loop{};
          println!("{:?}",v);

3.3.2 while 循环(p41[*])
    Rust 设计 loop{} 原因在于相比其它语言，Rust 要做更多的静态分析。 while true{} 及
    loop{} 在运行时无任何区别；主要是会影响编译器内部的静态分析结果。如
    a. 使用 loop{}
       let x;
       loop{ x = 1; break; }
       println!("{}", x);
       // 编译器可通过流程分析推理出 x = 1 必然在 println! 之前执行过故可打印变量 x
    b. 使用 while true{}
       let x;
       while true{ x = 1; break; }
       println!("{}", x);
      // 编译器认为 while 语句执行与运行阶段的值有关，因此编译器不确定 x 是否一定会被
         初始化(即"变量x有可能未初始化")故编译报错:"use of possibly-uninitialized `x`"

3.3.3 for 循环
    a. Rust 中的 for 类比其它语言中的 for-each 循环( Golang 为" for range ")但其没有
       三段式 for 循环语句(如 Golang 中的" for i:=0;i<len;i++ {} ")如
           let arr = &[1, 2, 3];
           for i in arr {
               println!("The number is {}", i);
           }
       // for 循环的主要用途是利用迭代器对包含同类型的多元素容器执行遍历，如数组、链表、
          HashMap、HashSet 等。在 Rust 中可轻松自定义定制容器和迭代器，因此也很容易使
          for 循环支持自定义类型
    b. for 循环内部亦可使用 break、continue 控制执行流程

*/

/*
0. 所有权和移动语义

11.1 什么是所有权(Ownership)
    所有权代表着以下意义：
    (0). 每个值在 Rust 中都有一个变量来管理它，这个变量就是这个值、这块内存的所有者
    (1). 每个值在一个时间点只有一个管理者
    (2). 当变量所在的作用域结束的时候，变量及其所代表的值将会被销毁

11.2 移动语义
    a. 一个变量将其拥有的值转移给另一个变量称为"所有权转移"。赋值语句、函数调用、函数
       返回、函数参数等都可能导致所有权转移
    b. Rust 中所有权转移是" 所有类型的默认语义 "，Rust 中的变量绑定操作默认是" move "
       语义即执行新的变量绑定后原来的变量就不能再被使用

11.3 复制语义
    a. 默认的 move 语义是 Rust 的一个重要设计但任何时候复制都需要调用 clone() 会显得
       非常繁锁。故对于一些简单类型如整数、字符、布尔等使其赋值时默认采用复制语义
    b. 凡是实现了 std::marker::Copy trait 的类型执行 copy 语义。如数字、字符、布尔等

11.4 Box 类型
    a. Box 类型是 Rust 中一种常用的指针类型。代表"拥有所有权的指针"，Box 类型永远是
       move 语义不能是 copy 语义(因 Rust 中的 copy 是浅复制，对于 Box 这样类型而言
       浅复制必然会造成二次释放问题)
    b. 对于 Rust 中的所有变量在使用前一定要合理初始化否则会出现编译错误，对于" Box<T>
       / &T / &mut T "类型，合理初始化意味着其一定指向了某个具体的对象不可能为空(如若
       确实需要"可能为空的指针"则必须使用类型" Option<Box<T>> ")
    c. Rust 中的保留关键字 box(小写) 可用于将变量装箱到堆上，其功能与" Box::new() "并
       没有本质区别(但 box 暂仅用于 nightly 版本且需要打开 feature gate 才能使用)

*/
#![feature(box_syntax)]
#[derive(Debug)]
struct T{
    value:i32
}
fn main() {
    let p : Box<T> = box T{value:1};
    println!("{:?}",p);
}

/*
11.5 Clone 与 Copy

11.5.1 Copy 的含义(p121[*])
    Copy 全名是" std::marker::Copy "

11.5.2 Copy 的实现条件(p121~122[*])
    a. 并非所有类型皆可实现 Copy trait。对于自定义类型，Rust 规定只有所有成员都实现了
        Copy trait 此类型才能实现 Copy trait
    b. 常用数字类型、bool类型、共享借用指针 & 都是具有 Copy 属性的类型。而 Box、Vec、
       可写借用指针 &mut 等类型皆不具备 Copy 属性的类型
    c. struct 和 enum 类型不会自动实现 Copy trait，且仅当 struct 和 enum 内部元素皆
       为 Copy 类型编译器才允许针对此类型实现 Copy trait

11.5.3 Clone 的含义(p122~123[*])
    a. " std::clone::Clone "有两个关联方法，其中" clone_from "是有默认实现的，依赖于
       clone 方法的实现
    b. clone 方法一般用于" 基于语义的复制 "操作，跟具体类型作用息息相关。比如对于 Box
       类型 clone 执行的是"深复制"，而对于 Rc 类型 clone 则是将引用计数值加 1
    // 需注意的一条规则：对于实现了 copy 的类型它的 clone 方法应与 copy 语义相容，即
       等同于" 按字节复制 "[*]

11.5.4 自动 derive
    简化重复实现 Copy、Clone trait 等

11.5.5 总结(p123[*])
    // Copy 和 Clone 两者区别
    当 T：Copy 时切勿在 Clone trait 内乱定义逻辑，故需指定一个类型是 Copy 时最好使用
    " #[derive(Copy,Clone)] "方式(避免手动实现 Clone 导致错误)

11.6 析构函数
    a. "析构函数(destructor)"与"构造函数(constructor)"相对
    b. "构造函数"是对象被创建时调用的函数而"析构函数"则是对象被销毁时调用的函数

11.6.1 资源管理
    a. 在创建变量时获取某种资源，在变量生命周期结束时释放资源是一种觉的设计模式
    b. RAII 手法是比 GC 更通用的资源管理手段，GC 只能管理内存而 RAII 可管理各种资源

11.6.2 主动析构(p126[*])
    a. 禁止主动调用析构函数。即主动调用如" v.drop(); "为非法调用(编译报错)
    b. 主动析构可通过标准库" std::mem::drop "函数调用如" drop(v); "
    c. 使用下划线" _ "接收的变量会被当场析构如" let _ = D(2); "
    d. 注意区分" std::mem::drop() "函数及" std::ops::Drop::drop() "函数

11.6.3 Drop VS Copy (p129[*])
    a. 欲实现 Copy trait 则类型必须满足一定的条件(类型可用 memcpy 方式执行复制操作
       且没有内存安全问题)
    b. 带有析构函数的类型不能是 Copy (两个身份不能同时存在于同一类型上)

11.6.4 析构标记(p129[?])

*/